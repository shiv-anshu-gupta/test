

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> components/EquationEvaluatorInChannelList.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-analyzeGroupsAndPublish.html">analyzeGroupsAndPublish</a></li><li><a href="module-axisBuilder.html">axisBuilder</a></li><li><a href="module-axisCalculator.html">axisCalculator</a></li><li><a href="module-calculateAndPublishMaxYAxes.html">calculateAndPublishMaxYAxes</a></li><li><a href="module-chartAxisAlignment.html">chartAxisAlignment</a></li><li><a href="module-chartComponent.html">chartComponent</a></li><li><a href="module-chartDomUtils.html">chartDomUtils</a></li><li><a href="module-chartManager.html">chartManager</a></li><li><a href="module-comtradeUtils.html">comtradeUtils</a></li><li><a href="module-createDragBar.html">createDragBar</a></li><li><a href="module-createState.html">createState</a></li><li><a href="module-domUpdateQueue.html">domUpdateQueue</a></li><li><a href="module-domUpdateQueueInit.html">domUpdateQueueInit</a></li><li><a href="module-handleVerticalLineShortcuts.html">handleVerticalLineShortcuts</a></li><li><a href="module-initVerticalLineControl.html">initVerticalLineControl</a></li><li><a href="module-main.html">main</a></li><li><a href="module-maxYAxesStore.html">maxYAxesStore</a></li><li><a href="module-mergerWindowLauncher.html">mergerWindowLauncher</a></li><li><a href="module-performanceMonitor.html">performanceMonitor</a></li><li><a href="module-seriesMapper.html">seriesMapper</a></li><li><a href="module-setupChartDragAndDrop.html">setupChartDragAndDrop</a></li><li><a href="module-timeInterpolation.html">timeInterpolation</a></li><li><a href="module-verticalLineControl.html">verticalLineControl</a></li></ul><h3>Classes</h3><ul><li><a href="ComputedChannelMetadata.html">ComputedChannelMetadata</a></li><li><a href="PolarChart.html">PolarChart</a></li><li><a href="module-performanceMonitor-PhaseTracker.html">PhaseTracker</a></li></ul><h3>Global</h3><ul><li><a href="global.html#IMPLEMENTATION_COMPLETE">IMPLEMENTATION_COMPLETE</a></li><li><a href="global.html#QUICK_REFERENCE">QUICK_REFERENCE</a></li><li><a href="global.html#STORAGE_KEY">STORAGE_KEY</a></li><li><a href="global.html#THEMES">THEMES</a></li><li><a href="global.html#applyTheme">applyTheme</a></li><li><a href="global.html#autoGroupChannels">autoGroupChannels</a></li><li><a href="global.html#calculateStats">calculateStats</a></li><li><a href="global.html#chart2">chart2</a></li><li><a href="global.html#clearCaches">clearCaches</a></li><li><a href="global.html#clearChartsContainer">clearChartsContainer</a></li><li><a href="global.html#clearComputedChannelsFromStorage">clearComputedChannelsFromStorage</a></li><li><a href="global.html#clearExpressionCache">clearExpressionCache</a></li><li><a href="global.html#collectChartDeltas">collectChartDeltas</a></li><li><a href="global.html#convertLatexToMathJs">convertLatexToMathJs</a></li><li><a href="global.html#convertLatexToPlainText">convertLatexToPlainText</a></li><li><a href="global.html#createAnalogChannelGroupMap">createAnalogChannelGroupMap</a></li><li><a href="global.html#createBinaryBlob">createBinaryBlob</a></li><li><a href="global.html#createChannelItem">createChannelItem</a></li><li><a href="global.html#createChannelList">createChannelList</a></li><li><a href="global.html#createChartContainer">createChartContainer</a></li><li><a href="global.html#createChartOptions">createChartOptions</a></li><li><a href="global.html#createComputedChannelsLabels">createComputedChannelsLabels</a></li><li><a href="global.html#createComputedChannelsSidebar">createComputedChannelsSidebar</a></li><li><a href="global.html#createDebouncedRender">createDebouncedRender</a></li><li><a href="global.html#createDeltaWindow">createDeltaWindow</a></li><li><a href="global.html#createDigitalFillPlugin">createDigitalFillPlugin</a></li><li><a href="global.html#createScopeTemplate">createScopeTemplate</a></li><li><a href="global.html#createSimpleChannelList">createSimpleChannelList</a></li><li><a href="global.html#createSimpleContainer">createSimpleContainer</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createTooltip">createTooltip</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#encodeFloat64">encodeFloat64</a></li><li><a href="global.html#encodeInt32">encodeInt32</a></li><li><a href="global.html#evaluateAndSaveComputedChannel">evaluateAndSaveComputedChannel</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#exportAllChannelsAsCSV">exportAllChannelsAsCSV</a></li><li><a href="global.html#exportAllComputedChannels">exportAllComputedChannels</a></li><li><a href="global.html#exportAsASCII">exportAsASCII</a></li><li><a href="global.html#exportComputedChannelAsASCII">exportComputedChannelAsASCII</a></li><li><a href="global.html#exportComputedChannelAsCFGDAT">exportComputedChannelAsCFGDAT</a></li><li><a href="global.html#exportComputedChannelsAsCSV">exportComputedChannelsAsCSV</a></li><li><a href="global.html#formatEquationForLatex">formatEquationForLatex</a></li><li><a href="global.html#generateCFGContent">generateCFGContent</a></li><li><a href="global.html#generateCFGContentBatch">generateCFGContentBatch</a></li><li><a href="global.html#generateCFGContentBinary32">generateCFGContentBinary32</a></li><li><a href="global.html#generateCFGContentBinary64">generateCFGContentBinary64</a></li><li><a href="global.html#generateCFGContentFloat32">generateCFGContentFloat32</a></li><li><a href="global.html#generateCFGContentFloat64">generateCFGContentFloat64</a></li><li><a href="global.html#generateDATContent">generateDATContent</a></li><li><a href="global.html#generateDATContentBatch">generateDATContentBatch</a></li><li><a href="global.html#generateDATContentBinary32">generateDATContentBinary32</a></li><li><a href="global.html#generateDATContentBinary64">generateDATContentBinary64</a></li><li><a href="global.html#generateDATContentFloat32">generateDATContentFloat32</a></li><li><a href="global.html#generateDATContentFloat64">generateDATContentFloat64</a></li><li><a href="global.html#getAllAvailableGroups">getAllAvailableGroups</a></li><li><a href="global.html#getCacheStats">getCacheStats</a></li><li><a href="global.html#getChannelByDisplayName">getChannelByDisplayName</a></li><li><a href="global.html#getChannelMetadata">getChannelMetadata</a></li><li><a href="global.html#getChannelsForFile">getChannelsForFile</a></li><li><a href="global.html#getCompiledExpression">getCompiledExpression</a></li><li><a href="global.html#getComputedChannelStorageMetadata">getComputedChannelStorageMetadata</a></li><li><a href="global.html#getCurrentTheme">getCurrentTheme</a></li><li><a href="global.html#getCurrentThemeColors">getCurrentThemeColors</a></li><li><a href="global.html#getFileIndexForTime">getFileIndexForTime</a></li><li><a href="global.html#getMemoryInfo">getMemoryInfo</a></li><li><a href="global.html#getOriginalChannelName">getOriginalChannelName</a></li><li><a href="global.html#getSampleIndexInFile">getSampleIndexInFile</a></li><li><a href="global.html#getThemeColor">getThemeColor</a></li><li><a href="global.html#groupCfgDatFiles">groupCfgDatFiles</a></li><li><a href="global.html#hasStoredComputedChannels">hasStoredComputedChannels</a></li><li><a href="global.html#hideTooltip">hideTooltip</a></li><li><a href="global.html#importComputedChannelFromJSON">importComputedChannelFromJSON</a></li><li><a href="global.html#initTheme">initTheme</a></li><li><a href="global.html#initUPlotChart">initUPlotChart</a></li><li><a href="global.html#initializeSidebarChannels">initializeSidebarChannels</a></li><li><a href="global.html#injectSidebarIntoUplot">injectSidebarIntoUplot</a></li><li><a href="global.html#loadComputedChannelsFromStorage">loadComputedChannelsFromStorage</a></li><li><a href="global.html#measurePerformance">measurePerformance</a></li><li><a href="global.html#mergeAnalogChannels">mergeAnalogChannels</a></li><li><a href="global.html#mergeComtradeFilesSetsSequential">mergeComtradeFilesSetsSequential</a></li><li><a href="global.html#mergeDigitalChannels">mergeDigitalChannels</a></li><li><a href="global.html#mergeTimeArraysSequential">mergeTimeArraysSequential</a></li><li><a href="global.html#openMathLiveEditor">openMathLiveEditor</a></li><li><a href="global.html#performExport">performExport</a></li><li><a href="global.html#processFilesInBatches">processFilesInBatches</a></li><li><a href="global.html#processInChunks">processInChunks</a></li><li><a href="global.html#renameChannelWithPrefix">renameChannelWithPrefix</a></li><li><a href="global.html#renderComputedChannels">renderComputedChannels</a></li><li><a href="global.html#renderComtradeCharts">renderComtradeCharts</a></li><li><a href="global.html#saveComputedChannelToGlobals">saveComputedChannelToGlobals</a></li><li><a href="global.html#saveComputedChannelsToStorage">saveComputedChannelsToStorage</a></li><li><a href="global.html#separateComputedFiles">separateComputedFiles</a></li><li><a href="global.html#setupMobileSidebar">setupMobileSidebar</a></li><li><a href="global.html#setupPolarChartWithVerticalLines">setupPolarChartWithVerticalLines</a></li><li><a href="global.html#showChannelListWindow">showChannelListWindow</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#showExportFormatDialog">showExportFormatDialog</a></li><li><a href="global.html#showFileInfo">showFileInfo</a></li><li><a href="global.html#sortFilePairs">sortFilePairs</a></li><li><a href="global.html#subscribeChartUpdates">subscribeChartUpdates</a></li><li><a href="global.html#toggleChartsVisibility">toggleChartsVisibility</a></li><li><a href="global.html#toggleTheme">toggleTheme</a></li><li><a href="global.html#updateComputedChannelsSidebar">updateComputedChannelsSidebar</a></li><li><a href="global.html#updateFileInfo">updateFileInfo</a></li><li><a href="global.html#updateStatsCards">updateStatsCards</a></li><li><a href="global.html#updateTooltip">updateTooltip</a></li><li><a href="global.html#validateSampleRates">validateSampleRates</a></li><li><a href="global.html#wrapChartInSection">wrapChartInSection</a></li><li><a href="global.html#yieldToEventLoop">yieldToEventLoop</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>components/EquationEvaluatorInChannelList.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * EquationEvaluatorInChannelList.js
 * Equation evaluator UI integrated into Channel List popup window
 */

import {
  generateCFGContentBinary32,
  generateDATContentBinary32,
  generateCFGContentBinary64,
  generateDATContentBinary64,
  generateCFGContentFloat32,
  generateDATContentFloat32,
  generateCFGContentFloat64,
  generateDATContentFloat64,
  createBinaryBlob,
} from "../utils/binaryExportUtils.js";
import {
  getCompiledExpression,
  createScopeTemplate,
  evaluateExpression,
  calculateStats,
  measurePerformance,
} from "../utils/computedChannelOptimization.js";
import { computedChannelMetadata } from "../utils/computedChannelMetadata.js";

export function createEquationEvaluatorInChannelList(
  cfg,
  data,
  containerEl,
  popupWindow
) {
  if (!containerEl) {
    console.warn(
      "createEquationEvaluatorInChannelList: containerEl not provided"
    );
    return;
  }

  const doc = popupWindow?.document || document;
  let computedChannelsCounter = 0;
  let currentComputation = null;

  // Create main container
  const section = doc.createElement("div");
  section.id = "equation-evaluator-popup";
  section.style.cssText = `
    padding: 16px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 8px;
    color: white;
    margin-bottom: 12px;
  `;

  section.innerHTML = `
    &lt;h3 style="margin: 0 0 12px 0; font-size: 18px; display: flex; align-items: center; gap: 8px;">
      &lt;span>ðŸ§®&lt;/span> Equation Evaluator
    &lt;/h3>
    
    &lt;div style="display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap; align-items: flex-end;">
      &lt;div style="flex: 1; min-width: 200px;">
        &lt;label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">Equation:&lt;/label>
        &lt;input 
          type="text" 
          id="equation-input-popup" 
          placeholder="e.g., sqrt(a0^2 + a1^2)" 
          style="width: 100%; padding: 8px; border: none; border-radius: 4px; box-sizing: border-box; font-family: monospace; font-size: 13px;"
        >
      &lt;/div>
      &lt;button 
        id="execute-btn-popup" 
        style="padding: 8px 16px; background: white; color: #667eea; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px; white-space: nowrap;"
      >
        â–¶ï¸ Execute
      &lt;/button>
      &lt;button 
        id="channels-btn-popup" 
        style="padding: 8px 16px; background: white; color: #667eea; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px; white-space: nowrap;"
      >
        ðŸ“‹ Channels
      &lt;/button>
    &lt;/div>

    &lt;div id="results-popup" style="background: white; border-radius: 6px; color: #333; padding: 12px; font-size: 13px;">
      &lt;div style="text-align: center; color: #999;">Enter an equation and click Execute&lt;/div>
    &lt;/div>
  `;

  containerEl.appendChild(section);

  const equationInput = section.querySelector("#equation-input-popup");
  const executeBtn = section.querySelector("#execute-btn-popup");
  const channelsBtn = section.querySelector("#channels-btn-popup");
  const resultsDiv = section.querySelector("#results-popup");

  executeBtn.onclick = () => {
    const equation = equationInput.value.trim();
    if (!equation) {
      resultsDiv.innerHTML =
        '&lt;div style="color: #e74c3c; text-align: center;">Please enter an equation&lt;/div>';
      return;
    }
    executeEquation(equation, resultsDiv, doc);
  };

  channelsBtn.onclick = () => showAllChannelsDialogPopup(cfg, data, doc);

  equationInput.onkeypress = (e) => {
    if (e.key === "Enter") executeBtn.click();
  };

  // Helper function to extract group from channels used in equation
  function extractGroupFromEquation(equation) {
    const usedGroups = [];

    // Extract channel IDs from equation (matches a0, a1, d0, d1, and full IDs)
    const channelRefPattern = /([ad]\d+|[a-zA-Z_]\w*)/g;
    const matches = equation.match(channelRefPattern) || [];
    const uniqueRefs = [...new Set(matches)];

    // Find which channels are used
    uniqueRefs.forEach((ref) => {
      // Check analog channels
      cfg?.analogChannels?.forEach((chCfg) => {
        if (
          chCfg.id === ref ||
          ref === `a${cfg.analogChannels.indexOf(chCfg)}`
        ) {
          if (chCfg.group) usedGroups.push(chCfg.group);
        }
      });

      // Check digital channels
      cfg?.digitalChannels?.forEach((chCfg) => {
        if (
          chCfg.id === ref ||
          ref === `d${cfg.digitalChannels.indexOf(chCfg)}`
        ) {
          if (chCfg.group) usedGroups.push(chCfg.group);
        }
      });
    });

    // Return the most common group, or empty string if none found
    if (usedGroups.length === 0) return "";

    const groupCounts = {};
    usedGroups.forEach((g) => {
      groupCounts[g] = (groupCounts[g] || 0) + 1;
    });

    // Return the group with highest count
    return Object.keys(groupCounts).reduce((a, b) =>
      groupCounts[a] > groupCounts[b] ? a : b
    );
  }

  // Execute equation logic
  function executeEquation(equation, resultsDivEl, ownerDoc) {
    try {
      const mathLib = popupWindow?.math || window.math;
      if (!mathLib) {
        throw new Error("Math.js not available. Please include mathjs CDN.");
      }

      // Prefer analogData/digitalData when present, else analog/digital
      const analogArray = Array.isArray(data?.analogData)
        ? data.analogData
        : Array.isArray(data?.analog)
        ? data.analog
        : [];
      const digitalArray = Array.isArray(data?.digitalData)
        ? data.digitalData
        : Array.isArray(data?.digital)
        ? data.digital
        : [];

      const sampleCount = analogArray?.[0]?.length || 0;
      if (!sampleCount) {
        resultsDivEl.innerHTML =
          '&lt;div style="color:#e74c3c;padding:10px;background:#fff5f5;border-radius:4px;font-size:12px;">No analog samples available in popup (analog/analogData empty). Ensure cfg/data are bound.&lt;/div>';
        return;
      }

      // âœ… OPTIMIZATION: Compile once with cache
      const compiled = measurePerformance("Compile expression", () =>
        getCompiledExpression(equation, mathLib)
      );

      // âœ… OPTIMIZATION: Pre-allocate scope object to reduce GC
      const scope = createScopeTemplate(
        analogArray.length,
        digitalArray.length
      );

      // âœ… OPTIMIZATION: High-performance evaluation loop
      const results = measurePerformance("Evaluate samples", () =>
        evaluateExpression(
          compiled,
          analogArray,
          digitalArray,
          cfg?.analogChannels,
          cfg?.digitalChannels,
          scope
        )
      );

      // âœ… OPTIMIZATION: Single-pass stats calculation
      const stats = calculateStats(results);

      // Auto-detect scaling
      const firstChannelData = analogArray?.[0] || [];
      const maxRaw = Math.max(...firstChannelData.map((v) => Math.abs(v)));
      const scalingFactor = maxRaw / 2;

      const scaledStats = {
        min: stats.min / scalingFactor,
        max: stats.max / scalingFactor,
        avg: stats.avg / scalingFactor,
      };

      // âœ… Convert Float64Array to regular array for better serialization
      const resultsArray = Array.from(results);

      currentComputation = {
        equation,
        results: resultsArray,
        stats,
        scaledStats,
        scalingFactor,
      };

      // âœ… FIX: Save to parent window, not popup window
      if (window.opener &amp;&amp; window.opener !== window) {
        window.opener.__currentComputedChannelData = currentComputation;
      } else {
        window.__currentComputedChannelData = currentComputation;
      }

      // âœ… OPTIMIZATION: Minimal HTML for instant display
      let html = `&lt;div style="background: #27AE60; color: white; padding: 10px; border-radius: 4px; margin-bottom: 10px;">&lt;strong>âœ“ Ready&lt;/strong>: ${
        resultsArray.length
      } samples | Min: ${stats.min.toFixed(2)} | Max: ${stats.max.toFixed(
        2
      )}&lt;/div>`;

      // âœ… Add LaTeX equation display with MathJax rendering
      html += `&lt;div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 10px; border-left: 3px solid #667eea;">&lt;strong style="color: #667eea; font-size: 13px;">Equation (LaTeX):&lt;/strong>&lt;div style="margin-top: 8px; padding: 8px; background: white; border-radius: 3px; font-size: 14px;">$$${equation}$$&lt;/div>&lt;/div>`;

      html += `&lt;div style="display: flex; gap: 8px;">&lt;button id="save-computed-btn-popup" style="flex: 1; padding: 10px; background: #27AE60; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px;">ðŸ’¾ Save&lt;/button>&lt;button id="clear-results-btn-popup" style="flex: 1; padding: 10px; background: #E74C3C; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px;">ðŸ—‘ï¸ Clear&lt;/button>&lt;/div>`;

      resultsDivEl.innerHTML = html;

      // âœ… Trigger MathJax to render LaTeX equations beautifully
      setTimeout(() => {
        if (ownerDoc.defaultView &amp;&amp; ownerDoc.defaultView.MathJax) {
          ownerDoc.defaultView.MathJax.typesetPromise &amp;&amp;
            ownerDoc.defaultView.MathJax.typesetPromise().catch((e) => {
              console.log("[MathJax] Rendering equations...");
            });
        }
      }, 100);

      const saveBtn = resultsDivEl.querySelector("#save-computed-btn-popup");
      const clearBtn = resultsDivEl.querySelector("#clear-results-btn-popup");

      saveBtn.onclick = () =>
        saveComputedChannelPopup(currentComputation, resultsDivEl, ownerDoc);
      clearBtn.onclick = () => {
        resultsDivEl.innerHTML =
          '&lt;div style="text-align: center; color: #999;">Enter an equation and click Execute&lt;/div>';
        currentComputation = null;
      };
    } catch (error) {
      resultsDivEl.innerHTML = `
        &lt;div style="color: #e74c3c; padding: 10px; background: #fff5f5; border-radius: 4px; font-size: 12px;">
          &lt;strong>Error:&lt;/strong> ${error.message}
        &lt;/div>
      `;
    }
  }

  function saveComputedChannelPopup(computation, resultsDivEl, ownerDoc) {
    const channelName = `computed_${computedChannelsCounter}`;
    computedChannelsCounter++;

    // Extract the group from channels used in the equation
    const usedGroup = extractGroupFromEquation(computation.equation);

    // Generate a random color for the computed channel (similar to how analog/digital channels get colors)
    const randomColor = "#" + Math.floor(Math.random() * 16777215).toString(16);

    // Store in data - with complete metadata similar to analog/digital channels
    if (!data.computedData) data.computedData = [];
    if (!cfg.computedChannels) cfg.computedChannels = [];

    // âœ… OPTIMIZATION: Pre-scale data during save to avoid runtime scaling
    const scaledData =
      computation.scalingFactor !== 1
        ? computation.results.map((v) => v / computation.scalingFactor)
        : computation.results;

    // Calculate stats for scaled data to display correctly in sidebar
    const scaledDataStats =
      computation.scalingFactor !== 1
        ? {
            min: computation.stats.min / computation.scalingFactor,
            max: computation.stats.max / computation.scalingFactor,
            avg: computation.stats.avg / computation.scalingFactor,
            mean: computation.stats.mean / computation.scalingFactor,
            rms: computation.stats.rms
              ? computation.stats.rms / computation.scalingFactor
              : undefined,
            stdDev: computation.stats.stdDev
              ? computation.stats.stdDev / computation.scalingFactor
              : undefined,
            count: computation.stats.count,
            validCount: computation.stats.validCount,
          }
        : computation.stats;

    data.computedData.push({
      id: channelName,
      name: channelName,
      equation: computation.equation,
      data: scaledData,
      stats: scaledDataStats,
      scaledStats: computation.scaledStats,
      scalingFactor: computation.scalingFactor,
      color: randomColor,
      type: "Computed",
      unit: "Computed",
      group: usedGroup,
    });

    // Register in cfg with complete metadata
    cfg.computedChannels.push({
      id: channelName,
      name: channelName,
      equation: computation.equation,
      unit: "Computed",
      group: usedGroup,
      color: randomColor,
      type: "Computed",
      index: data.computedData.length - 1,
    });

    // ðŸ“Š Store metadata in centralized metadata manager
    computedChannelMetadata.set(channelName, {
      name: channelName,
      equation: computation.equation,
      latexEquation: computation.equation, // Will be formatted for LaTeX display
      mathJsExpression: computation.equation,
      color: randomColor,
      group: usedGroup || "Computed",
      unit: "Computed",
      type: "Computed",
      stats: computation.stats,
      scalingFactor: computation.scalingFactor,
      description: `Auto-computed channel from equation`,
    });

    // Show success
    const successMsg = ownerDoc.createElement("div");
    successMsg.style.cssText = `
      color: white; 
      background: #27AE60; 
      padding: 10px; 
      border-radius: 4px; 
      margin-top: 8px; 
      text-align: center; 
      font-weight: 600;
      font-size: 12px;
      animation: fadeOut 3s ease-in-out forwards;
    `;
    successMsg.textContent = `âœ… Saved "${channelName}" (${computation.results.length} samples)`;

    // Add animation if not present
    const existingStyle = ownerDoc.head.querySelector(
      "style[data-animation-popup]"
    );
    if (!existingStyle) {
      const style = ownerDoc.createElement("style");
      style.setAttribute("data-animation-popup", "true");
      style.textContent = `
        @keyframes fadeOut {
          0% { opacity: 1; }
          70% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      ownerDoc.head.appendChild(style);
    }

    resultsDivEl.parentElement.insertBefore(
      successMsg,
      resultsDivEl.nextSibling
    );
    setTimeout(() => successMsg.remove(), 3000);

    console.log("[EquationEvaluatorPopup] Saved:", channelName);

    // Dispatch custom event to parent window with complete channel data
    if (window.opener) {
      console.log(
        "[EquationEvaluatorPopup] Dispatching event to parent window"
      );
      const computedChannelData = {
        id: channelName,
        name: channelName,
        equation: computation.equation,
        data: scaledData,
        stats: computation.stats,
        scaledStats: computation.scaledStats,
        scalingFactor: computation.scalingFactor,
        color: randomColor,
        type: "Computed",
        unit: "Computed",
        group: usedGroup,
      };
      window.opener.dispatchEvent(
        new CustomEvent("computedChannelSaved", {
          detail: {
            channelId: channelName,
            channelName: channelName,
            equation: computation.equation,
            samples: computation.results.length,
            color: randomColor,
            type: "Computed",
            group: usedGroup,
            fullData: computedChannelData,
          },
        })
      );
    } else {
      console.warn("[EquationEvaluatorPopup] No opener window found");
    }
  }

  function showAllChannelsDialogPopup(cfgData, dataData, ownerDoc) {
    const modal = ownerDoc.createElement("div");
    modal.style.cssText = `
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background: rgba(0,0,0,0.5); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      z-index: 10001;
    `;

    const dialog = ownerDoc.createElement("div");
    dialog.style.cssText = `
      background: white; 
      border-radius: 8px; 
      padding: 20px; 
      max-width: 700px; 
      max-height: 70vh; 
      overflow: auto; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.3); 
      color: #333;
      font-size: 13px;
    `;

    let html = `&lt;h3 style="margin-top: 0; color: #667eea; font-size: 16px;">Available Channels&lt;/h3>`;

    const totalSamples =
      dataData?.analog?.[0]?.length || dataData?.analogData?.[0]?.length || 0;
    html += `&lt;p style="font-size: 12px; color: #666;">&lt;strong>Total Samples:&lt;/strong> ${totalSamples}&lt;/p>`;

    // Analog
    if (cfgData.analogChannels?.length > 0) {
      html += `&lt;h4 style="color: #667eea; margin-top: 12px; margin-bottom: 8px;">Analog Channels (${cfgData.analogChannels.length})&lt;/h4>`;
      html += '&lt;ul style="list-style: none; padding: 0; margin: 0;">';
      cfgData.analogChannels.forEach((ch, i) => {
        html += `&lt;li style="padding: 6px; background: #f5f5f5; margin-bottom: 4px; border-radius: 3px; border-left: 3px solid #667eea; font-size: 12px;">
          &lt;strong>a${i}: ${ch.id || "Analog " + i}&lt;/strong> - ${
          ch.unit || "N/A"
        }
        &lt;/li>`;
      });
      html += "&lt;/ul>";
    }

    // Digital
    if (cfgData.digitalChannels?.length > 0) {
      html += `&lt;h4 style="color: #667eea; margin-top: 12px; margin-bottom: 8px;">Digital Channels (${cfgData.digitalChannels.length})&lt;/h4>`;
      html += '&lt;ul style="list-style: none; padding: 0; margin: 0;">';
      cfgData.digitalChannels.forEach((ch, i) => {
        html += `&lt;li style="padding: 6px; background: #f5f5f5; margin-bottom: 4px; border-radius: 3px; border-left: 3px solid #667eea; font-size: 12px;">
          &lt;strong>d${i}: ${ch.id || "Digital " + i}&lt;/strong>
        &lt;/li>`;
      });
      html += "&lt;/ul>";
    }

    // Computed
    if (dataData.computedData?.length > 0) {
      html += `&lt;h4 style="color: #27AE60; margin-top: 12px; margin-bottom: 8px;">ðŸ§® Computed Channels (${dataData.computedData.length})&lt;/h4>`;
      html += '&lt;ul style="list-style: none; padding: 0; margin: 0;">';
      dataData.computedData.forEach((ch, i) => {
        html += `&lt;li style="padding: 8px; background: #D5F4E6; margin-bottom: 4px; border-radius: 3px; border-left: 3px solid #27AE60; font-size: 12px;">
          &lt;div>&lt;strong>c${i}: ${ch.id}&lt;/strong>&lt;/div>
          &lt;div style="color: #555; margin-top: 3px; font-family: monospace; font-size: 11px;">${ch.equation}&lt;/div>
        &lt;/li>`;
      });
      html += "&lt;/ul>";
    }

    dialog.innerHTML = html;

    const closeBtn = ownerDoc.createElement("button");
    closeBtn.textContent = "âœ• Close";
    closeBtn.style.cssText = `
      width: 100%; 
      padding: 10px; 
      background: #667eea; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      margin-top: 16px; 
      font-weight: 600; 
      font-size: 13px;
    `;
    closeBtn.onclick = () => modal.remove();
    dialog.appendChild(closeBtn);

    modal.appendChild(dialog);
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    ownerDoc.body.appendChild(modal);
  }
}

/**
 * Export computed channel data as JSON format (importable)
 * @param {Object} computation - Computation object with results, stats, equation, etc
 */
export function exportComputedChannelAsASCII(computation) {
  try {
    if (
      !computation ||
      !computation.results ||
      !Array.isArray(computation.results)
    ) {
      alert("âŒ No data to export. Please execute an equation first.");
      return;
    }

    const timestamp = new Date()
      .toISOString()
      .replace(/[:.]/g, "-")
      .slice(0, -5);
    const fileName = `computed_channel_${timestamp}.json`;

    // Create JSON export with all metadata and data
    const exportData = {
      format: "COMTRADE_COMPUTED_CHANNEL_v1",
      exportedAt: new Date().toISOString(),
      channel: {
        id: `computed_${Date.now()}`,
        equation: computation.equation,
        scalingFactor: computation.scalingFactor,
        stats: {
          count: computation.stats.count,
          validCount: computation.stats.validCount,
          min: computation.stats.min,
          max: computation.stats.max,
          avg: computation.stats.avg,
        },
        scaledStats: {
          min: computation.scaledStats.min,
          max: computation.scaledStats.max,
          avg: computation.scaledStats.avg,
        },
      },
      data: computation.results, // Array of raw values
    };

    // Create blob and trigger download
    const jsonContent = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonContent], {
      type: "application/json;charset=utf-8;",
    });
    const link = document.createElement("a");
    link.setAttribute("href", URL.createObjectURL(blob));
    link.setAttribute("download", fileName);
    link.style.visibility = "hidden";

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Show success notification
    console.log(
      `[ExportJSON] âœ… Exported ${computation.results.length} samples to ${fileName}`
    );
    alert(
      `âœ… Successfully exported!\n\nFile: ${fileName}\nSamples: ${computation.results.length}\nEquation: ${computation.equation}\n\nYou can import this file later to reuse the channel.`
    );
  } catch (error) {
    console.error("[ExportJSON] Error:", error);
    alert(`âŒ Export failed: ${error.message}`);
  }
}

/**
 * Export computed channel as CFG file (COMTRADE 2013 format)
 * @param {Object} computation - Computation object
 * @param {number} sampleRate - Sample rate from original COMTRADE
 * @returns {string} CFG file content
 */
export function generateCFGContent(computation, sampleRate = 4800) {
  // Calculate multiplier and offset for proper scaling
  // Format: raw_value * multiplier + offset = display_value
  // We store raw values, so multiplier converts to display
  const min = computation.stats.min;
  const max = computation.stats.max;
  const range = max - min;

  // COMTRADE uses 32-bit signed integer range: -2147483648 to 2147483647
  const intMin = -2147483648;
  const intMax = 2147483647;
  const intRange = intMax - intMin;

  // Multiplier: how much each raw unit represents in real values
  const multiplier = range / intRange;
  const offset = min - intMin * multiplier;

  let cfg = "";

  // Line 1: Station,Device,COMTRADE version
  cfg += `MID=COMPUTED_CHANNEL,EQUATION_${Date.now()},2013\n`;

  // Line 2: Total channels, Analog channels, Digital channels
  cfg += `1,1A,0D\n`;

  // Analog channel definition
  // Index,Id,Phase,Component,Unit,Multiplier,Offset,Skew,Min,Max,Primary,Secondary,PS
  cfg += `1,COMPUTED,,,V,${multiplier.toExponential(15)},${offset.toExponential(
    15
  )},0,${intMin},${intMax},${sampleRate},1,P\n`;

  // Digital channels count line
  cfg += `0\n`;

  // Sampling rates: N, rate1, endSample1, [rate2, endSample2, ...]
  const totalSamples = computation.results.length;
  cfg += `0\n`;
  cfg += `${sampleRate},${totalSamples}\n`;

  // Time format: DD/MM/YYYY,HH:MM:SS.mmmmmm
  const now = new Date();
  const day = String(now.getDate()).padStart(2, "0");
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const year = now.getFullYear();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  const microseconds = String(now.getMilliseconds() * 1000).padStart(6, "0");

  const timeStr = `${day}/${month}/${year},${hours}:${minutes}:${seconds}.${microseconds}`;

  // Start time (same as trigger time for computed channels)
  cfg += `${timeStr}\n`;
  // Trigger time (same as start time)
  cfg += `${timeStr}\n`;

  // File type
  cfg += `ASCII\n`;

  // Time multiplier (1.0 means use sample rate timing)
  cfg += `1.0\n`;

  // Time offset (COMTRADE 2013 specific)
  cfg += `0\n`;
  cfg += `0\n`;

  return cfg;
}

/**
 * Export computed channel as DAT file (ASCII format, COMTRADE 2013 compatible)
 * COMTRADE ASCII Format: sample#,milliseconds,value1[,value2...]
 * @param {Object} computation - Computation object
 * @param {number} sampleRate - Sample rate from original COMTRADE
 * @returns {string} DAT file content (ASCII COMTRADE format)
 */
export function generateDATContent(computation, sampleRate = 4800) {
  // Calculate multiplier for converting display values to raw integer values
  const min = computation.stats.min;
  const max = computation.stats.max;
  const range = max - min;
  const intMin = -2147483648;
  const intMax = 2147483647;
  const intRange = intMax - intMin;
  const multiplier = range / intRange;
  const offset = min - intMin * multiplier;

  let dat = "";

  // COMTRADE ASCII format: sample_number,timestamp_milliseconds,channel_value
  // timestamp is in milliseconds from start
  computation.results.forEach((value, idx) => {
    // Sample number (1-based)
    const sampleNum = idx + 1;

    // Timestamp in milliseconds
    const timestampMs = Math.round((idx / sampleRate) * 1000);

    // Convert display value to raw integer value using the multiplier/offset
    // display_value = raw_value * multiplier + offset
    // raw_value = (display_value - offset) / multiplier
    const rawValue = Math.round((value - offset) / multiplier);

    // Format: sample#,time_ms,value
    dat += `${sampleNum},${timestampMs},${rawValue}\n`;
  });

  return dat;
}

/**
 * Export computed channel as CFG + DAT files (compatible with load functionality)
 * @param {Object} computation - Computation object
 * @param {number} sampleRate - Sample rate from original COMTRADE
 */
export function exportComputedChannelAsCFGDAT(computation, sampleRate = 4800) {
  try {
    if (
      !computation ||
      !computation.results ||
      !Array.isArray(computation.results)
    ) {
      alert("âŒ No data to export. Please execute an equation first.");
      return;
    }

    const timestamp = new Date()
      .toISOString()
      .replace(/[:.]/g, "-")
      .slice(0, -5);
    const baseName = `computed_channel_${timestamp}`;

    // Generate CFG content
    const cfgContent = generateCFGContent(computation, sampleRate);
    const cfgFileName = `${baseName}.cfg`;

    // Generate DAT content
    const datContent = generateDATContent(computation, sampleRate);
    const datFileName = `${baseName}.dat`;

    // Download CFG
    const cfgBlob = new Blob([cfgContent], {
      type: "text/plain;charset=utf-8;",
    });
    const cfgLink = document.createElement("a");
    cfgLink.setAttribute("href", URL.createObjectURL(cfgBlob));
    cfgLink.setAttribute("download", cfgFileName);
    cfgLink.style.visibility = "hidden";
    document.body.appendChild(cfgLink);
    cfgLink.click();
    document.body.removeChild(cfgLink);

    // Download DAT (after small delay so browser doesn't block)
    setTimeout(() => {
      const datBlob = new Blob([datContent], {
        type: "text/plain;charset=utf-8;",
      });
      const datLink = document.createElement("a");
      datLink.setAttribute("href", URL.createObjectURL(datBlob));
      datLink.setAttribute("download", datFileName);
      datLink.style.visibility = "hidden";
      document.body.appendChild(datLink);
      datLink.click();
      document.body.removeChild(datLink);
    }, 500);

    console.log(
      `[ExportCFGDAT] âœ… Exported as ${cfgFileName} and ${datFileName}`
    );
    alert(
      `âœ… Successfully exported!\n\nFiles:\n  â€¢ ${cfgFileName}\n  â€¢ ${datFileName}\n\nDownload both files together.\nThen use "Select and Load Files" to import them!`
    );
  } catch (error) {
    console.error("[ExportCFGDAT] Error:", error);
    alert(`âŒ Export failed: ${error.message}`);
  }
}

/**
 * Import computed channel from JSON file
 * @param {File} file - JSON file to import
 */
export function importComputedChannelFromJSON(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);

        // Validate format
        if (data.format !== "COMTRADE_COMPUTED_CHANNEL_v1") {
          throw new Error(
            "Invalid format. Please use a file exported from this application."
          );
        }

        if (!data.channel || !data.data || !Array.isArray(data.data)) {
          throw new Error("Invalid file structure.");
        }

        console.log("[ImportJSON] âœ… File imported successfully");
        resolve({
          equation: data.channel.equation,
          results: data.data,
          stats: data.channel.stats,
          scaledStats: data.channel.scaledStats,
          scalingFactor: data.channel.scalingFactor,
        });
      } catch (error) {
        console.error("[ImportJSON] Error parsing:", error);
        reject(error);
      }
    };

    reader.onerror = (error) => {
      reject(new Error("Failed to read file: " + error));
    };

    reader.readAsText(file);
  });
}

/**
 * Generate CFG content for multiple computed channels (COMTRADE 2013)
 * @param {Array} computedChannels - Array of computed channel objects
 * @param {number} sampleRate - Sample rate
 * @returns {string} CFG content
 */
function generateCFGContentBatch(computedChannels, sampleRate = 4800) {
  const numAnalog = computedChannels.length;

  let cfg = "";

  // Line 1: Station,Device,COMTRADE version
  cfg += `MID=COMPUTED_CHANNELS,BATCH_${Date.now()},2013\n`;

  // Line 2: Total channels, Analog channels, Digital channels
  cfg += `${numAnalog},${numAnalog}A,0D\n`;

  // Analog channel definitions - one per computed channel
  computedChannels.forEach((ch, idx) => {
    const min = ch.stats?.min || 0;
    const max = ch.stats?.max || 1;
    const range = max - min;

    const intMin = -2147483648;
    const intMax = 2147483647;
    const intRange = intMax - intMin;

    const multiplier = range / intRange;
    const offset = min - intMin * multiplier;

    const chNum = idx + 1;
    const chId = ch.id || `computed_${idx}`;

    // Index,Id,Phase,Component,Unit,Multiplier,Offset,Skew,Min,Max,Primary,Secondary,PS
    cfg += `${chNum},${chId},,,${ch.unit || "V"},${multiplier.toExponential(
      15
    )},${offset.toExponential(15)},0,${intMin},${intMax},${sampleRate},1,P\n`;
  });

  // Digital channels count line
  cfg += `0\n`;

  // Sampling rates
  const totalSamples = computedChannels[0]?.data?.length || 0;
  cfg += `0\n`;
  cfg += `${sampleRate},${totalSamples}\n`;

  // Time format
  const now = new Date();
  const day = String(now.getDate()).padStart(2, "0");
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const year = now.getFullYear();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  const microseconds = String(now.getMilliseconds() * 1000).padStart(6, "0");

  const timeStr = `${day}/${month}/${year},${hours}:${minutes}:${seconds}.${microseconds}`;

  cfg += `${timeStr}\n`;
  cfg += `${timeStr}\n`;

  cfg += `ASCII\n`;
  cfg += `1.0\n`;
  cfg += `0\n`;
  cfg += `0\n`;

  return cfg;
}

/**
 * Generate DAT content for multiple computed channels (COMTRADE 2013)
 * @param {Array} computedChannels - Array of computed channel objects
 * @param {number} sampleRate - Sample rate
 * @returns {string} DAT content
 */
function generateDATContentBatch(computedChannels, sampleRate = 4800) {
  let dat = "";

  // Assuming all channels have same number of samples
  const totalSamples = computedChannels[0]?.data?.length || 0;

  for (let idx = 0; idx &lt; totalSamples; idx++) {
    const sampleNum = idx + 1;
    const timestampMs = Math.round((idx / sampleRate) * 1000);

    dat += `${sampleNum},${timestampMs}`;

    // Add value for each channel
    computedChannels.forEach((ch) => {
      const value = ch.data?.[idx] || 0;
      const min = ch.stats?.min || 0;
      const max = ch.stats?.max || 1;
      const range = max - min;

      const intMin = -2147483648;
      const intMax = 2147483647;
      const intRange = intMax - intMin;

      const multiplier = range / intRange;
      const offset = min - intMin * multiplier;

      // Convert display value to raw integer
      const rawValue = Math.round((value - offset) / multiplier);
      dat += `,${rawValue}`;
    });

    dat += "\n";
  }

  return dat;
}

/**
 * Show export format selection dialog
 * @param {Object} data - Data object containing computedData array
 * @param {number} sampleRate - Sample rate from original COMTRADE
 * @returns {void}
 */
function showExportFormatDialog(data, sampleRate) {
  return new Promise((resolve) => {
    // Create modal dialog
    const modal = document.createElement("div");
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    `;

    const dialogBox = document.createElement("div");
    dialogBox.style.cssText = `
      background: white;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      min-width: 400px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

    dialogBox.innerHTML = `
      &lt;h2 style="margin: 0 0 20px 0; color: #333; font-size: 20px;">ðŸ“¥ Export Format Selection&lt;/h2>
      
      &lt;div style="margin-bottom: 20px; max-height: 400px; overflow-y: auto;">
        &lt;label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
          &lt;input type="radio" name="export-format" value="ascii" checked style="margin-right: 10px; cursor: pointer;">
          &lt;span style="font-weight: 500; color: #333;">ASCII Format&lt;/span>
          &lt;span style="color: #999; font-size: 12px; margin-left: 8px;">(Text, human-readable, larger file)&lt;/span>
        &lt;/label>
        
        &lt;label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
          &lt;input type="radio" name="export-format" value="binary32" style="margin-right: 10px; cursor: pointer;">
          &lt;span style="font-weight: 500; color: #333;">Binary 32-bit Format&lt;/span>
          &lt;span style="color: #999; font-size: 12px; margin-left: 8px;">(32-bit signed integers, compact)&lt;/span>
        &lt;/label>
        
        &lt;label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
          &lt;input type="radio" name="export-format" value="binary64" style="margin-right: 10px; cursor: pointer;">
          &lt;span style="font-weight: 500; color: #333;">Binary 64-bit Format&lt;/span>
          &lt;span style="color: #999; font-size: 12px; margin-left: 8px;">(64-bit signed integers, maximum range)&lt;/span>
        &lt;/label>

        &lt;label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
          &lt;input type="radio" name="export-format" value="float32" style="margin-right: 10px; cursor: pointer;">
          &lt;span style="font-weight: 500; color: #333;">Float 32-bit Format&lt;/span>
          &lt;span style="color: #999; font-size: 12px; margin-left: 8px;">(IEEE 754 32-bit floats, ~7 decimals)&lt;/span>
        &lt;/label>
        
        &lt;label style="display: flex; align-items: center; cursor: pointer;">
          &lt;input type="radio" name="export-format" value="float64" style="margin-right: 10px; cursor: pointer;">
          &lt;span style="font-weight: 500; color: #333;">Float 64-bit Format&lt;/span>
          &lt;span style="color: #999; font-size: 12px; margin-left: 8px;">(IEEE 754 64-bit doubles, ~15 decimals)&lt;/span>
        &lt;/label>
      &lt;/div>

      &lt;div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 24px;">
        &lt;button id="cancel-export-btn" style="padding: 8px 16px; border: 1px solid #ccc; border-radius: 4px; background: white; color: #333; cursor: pointer; font-weight: 500;">
          Cancel
        &lt;/button>
        &lt;button id="confirm-export-btn" style="padding: 8px 16px; border: none; border-radius: 4px; background: #667eea; color: white; cursor: pointer; font-weight: 500;">
          Export âœ…
        &lt;/button>
      &lt;/div>
    `;

    modal.appendChild(dialogBox);
    document.body.appendChild(modal);

    const cancelBtn = dialogBox.querySelector("#cancel-export-btn");
    const confirmBtn = dialogBox.querySelector("#confirm-export-btn");
    const formatRadios = dialogBox.querySelectorAll(
      "input[name='export-format']"
    );

    let selectedFormat = "ascii";

    formatRadios.forEach((radio) => {
      radio.addEventListener("change", (e) => {
        selectedFormat = e.target.value;
      });
    });

    cancelBtn.addEventListener("click", () => {
      document.body.removeChild(modal);
      resolve(null);
    });

    confirmBtn.addEventListener("click", () => {
      document.body.removeChild(modal);
      resolve(selectedFormat);
    });

    // Allow Enter to confirm
    confirmBtn.focus();
  });
}

/**
 * Export computed channels in specified format
 * @param {string} format - Export format: 'ascii', 'binary32', or 'binary64'
 * @param {Object} data - Data object containing computedData array
 * @param {number} sampleRate - Sample rate from original COMTRADE
 * @returns {void}
 */
function performExport(format, data, sampleRate) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);

  let cfgContent, datContent, cfgFileName, datFileName, cfgBlob, datBlob;
  const formatLabels = {
    ascii: "ASCII",
    binary32: "Binary 32-bit",
    binary64: "Binary 64-bit",
    float32: "Float 32-bit",
    float64: "Float 64-bit",
  };
  const formatLabel = formatLabels[format] || "Unknown";

  try {
    if (format === "ascii") {
      // ASCII export
      const baseName = `computed_channels_batch_${timestamp}`;
      cfgContent = generateCFGContentBatch(data.computedData, sampleRate);
      cfgFileName = `${baseName}_ASCII.cfg`;
      datContent = generateDATContentBatch(data.computedData, sampleRate);
      datFileName = `${baseName}_ASCII.dat`;

      cfgBlob = new Blob([cfgContent], { type: "text/plain;charset=utf-8;" });
      datBlob = new Blob([datContent], { type: "text/plain;charset=utf-8;" });
    } else if (format === "binary32") {
      // Binary 32-bit export
      const baseName = `computed_channels_batch_${timestamp}`;
      cfgContent = generateCFGContentBinary32(data.computedData, sampleRate);
      cfgFileName = `${baseName}_BINARY32.cfg`;
      datContent = generateDATContentBinary32(data.computedData, sampleRate);
      datFileName = `${baseName}_BINARY32.dat`;

      cfgBlob = new Blob([cfgContent], { type: "text/plain;charset=utf-8;" });
      datBlob = createBinaryBlob(datContent);
    } else if (format === "binary64") {
      // Binary 64-bit export
      const baseName = `computed_channels_batch_${timestamp}`;
      cfgContent = generateCFGContentBinary64(data.computedData, sampleRate);
      cfgFileName = `${baseName}_BINARY64.cfg`;
      datContent = generateDATContentBinary64(data.computedData, sampleRate);
      datFileName = `${baseName}_BINARY64.dat`;

      cfgBlob = new Blob([cfgContent], { type: "text/plain;charset=utf-8;" });
      datBlob = createBinaryBlob(datContent);
    } else if (format === "float32") {
      // Float 32-bit export
      const baseName = `computed_channels_batch_${timestamp}`;
      cfgContent = generateCFGContentFloat32(data.computedData, sampleRate);
      cfgFileName = `${baseName}_FLOAT32.cfg`;
      datContent = generateDATContentFloat32(data.computedData, sampleRate);
      datFileName = `${baseName}_FLOAT32.dat`;

      cfgBlob = new Blob([cfgContent], { type: "text/plain;charset=utf-8;" });
      datBlob = createBinaryBlob(datContent);
    } else if (format === "float64") {
      // Float 64-bit export
      const baseName = `computed_channels_batch_${timestamp}`;
      cfgContent = generateCFGContentFloat64(data.computedData, sampleRate);
      cfgFileName = `${baseName}_FLOAT64.cfg`;
      datContent = generateDATContentFloat64(data.computedData, sampleRate);
      datFileName = `${baseName}_FLOAT64.dat`;

      cfgBlob = new Blob([cfgContent], { type: "text/plain;charset=utf-8;" });
      datBlob = createBinaryBlob(datContent);
    } else {
      throw new Error("Invalid format selected");
    }

    // Download CFG
    const cfgLink = document.createElement("a");
    cfgLink.setAttribute("href", URL.createObjectURL(cfgBlob));
    cfgLink.setAttribute("download", cfgFileName);
    cfgLink.style.visibility = "hidden";
    document.body.appendChild(cfgLink);
    cfgLink.click();
    document.body.removeChild(cfgLink);

    // Download DAT (after delay)
    setTimeout(() => {
      const datLink = document.createElement("a");
      datLink.setAttribute("href", URL.createObjectURL(datBlob));
      datLink.setAttribute("download", datFileName);
      datLink.style.visibility = "hidden";
      document.body.appendChild(datLink);
      datLink.click();
      document.body.removeChild(datLink);
    }, 500);

    console.log(
      `[ExportBatch] âœ… Exported ${data.computedData.length} channels as ${cfgFileName} and ${datFileName} (${formatLabel})`
    );
    alert(
      `âœ… Successfully exported ${data.computedData.length} computed channel(s) in ${formatLabel} format!\n\nFiles:\n  â€¢ ${cfgFileName}\n  â€¢ ${datFileName}\n\nDownload both files together.\nThen use "Select and Load Files" to import them!`
    );
  } catch (error) {
    console.error("[ExportBatch] Error:", error);
    alert(`âŒ Export failed: ${error.message}`);
  }
}

/**
 * Export all computed channels as CFG + DAT (COMTRADE 2013 format)
 * Supports ASCII, Binary 32-bit, and Binary 64-bit formats
 * @param {Object} data - Data object containing computedData array
 * @param {number} sampleRate - Sample rate from original COMTRADE
 * @returns {void}
 */
export async function exportAllComputedChannels(data, sampleRate = 4800) {
  try {
    if (
      !data?.computedData ||
      !Array.isArray(data.computedData) ||
      data.computedData.length === 0
    ) {
      alert("âŒ No computed channels to export.");
      return;
    }

    // Show format selection dialog
    const selectedFormat = await showExportFormatDialog(data, sampleRate);

    if (selectedFormat === null) {
      console.log("[ExportBatch] Export cancelled by user");
      return;
    }

    // Perform export in selected format
    performExport(selectedFormat, data, sampleRate);
  } catch (error) {
    console.error("[ExportBatch] Error:", error);
    alert(`âŒ Export failed: ${error.message}`);
  }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
