

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> plugins/digitalFillPlugin.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-chartComponent.html">chartComponent</a></li><li><a href="module-chartDomUtils.html">chartDomUtils</a></li><li><a href="module-chartManager.html">chartManager</a></li><li><a href="module-comtradeUtils.html">comtradeUtils</a></li><li><a href="module-createDragBar.html">createDragBar</a></li><li><a href="module-handleVerticalLineShortcuts.html">handleVerticalLineShortcuts</a></li><li><a href="module-main.html">main</a></li><li><a href="module-renderAnalogCharts.html">renderAnalogCharts</a></li><li><a href="module-renderComtradeCharts.html">renderComtradeCharts</a></li><li><a href="module-renderDigitalCharts.html">renderDigitalCharts</a></li><li><a href="module-setupChartDragAndDrop.html">setupChartDragAndDrop</a></li><li><a href="module-showChannelListWindow.html">showChannelListWindow</a></li><li><a href="module-timeInterpolation.html">timeInterpolation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#autoGroupChannels">autoGroupChannels</a></li><li><a href="global.html#createChannelList">createChannelList</a></li><li><a href="global.html#createChartContainer">createChartContainer</a></li><li><a href="global.html#createChartOptions">createChartOptions</a></li><li><a href="global.html#createDigitalFillPlugin">createDigitalFillPlugin</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createTooltip">createTooltip</a></li><li><a href="global.html#hideTooltip">hideTooltip</a></li><li><a href="global.html#initUPlotChart">initUPlotChart</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#subscribeChartUpdates">subscribeChartUpdates</a></li><li><a href="global.html#updateTooltip">updateTooltip</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>plugins/digitalFillPlugin.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * uPlot plugin for rendering filled regions under digital (boolean) signals.
 *
 * This plugin draws filled rectangles under digital signals (step lines) when the signal is in the "high" state (as defined by targetVal).
 * It supports multiple digital signals, each with its own vertical offset, color, and target value.
 *
 * The fill is drawn in sync with zoom/pan and respects the current axis scales.
 *
 *
 * @warning offset is expected to be always even when u.data contains offset. Else, define yData as
 * @param {Array&lt;Object>} signals - Array of signal configuration objects.
 *   Each object should have:
 *     - signalIndex {number}: Index of the signal in the uPlot data array (e.g., 1 for the first signal after x).
 *     - offset {number}: Vertical offset to apply to the signal (for stacking multiple signals).
 *     - color {string}: Fill color for the high region (CSS color, e.g., 'rgba(0,150,255,0.3)').
 *     - targetVal {number}: Value to consider as "high" (usually 1).
 *
 * @returns {Object} uPlot plugin object to be included in the `plugins` array of uPlot options.
 *
 * @example
 * import { createDigitalFillPlugin } from './src/plugins/digitalFillPlugin.js';
 *
 * const xVals = [0, 1, 2, 3, 4, 5, 6];
 * const signal1 = [1, 0, 1, 1, 0, 1, 0];
 * const signal2 = [1, 1, 1, 0, 1, 1, 1];
 *
 * const signals = [
 *   { signalIndex: 1, offset: 0, color: 'rgba(0, 150, 255, 0.3)', targetVal: 1 },
 *   { signalIndex: 2, offset: 3, color: 'rgba(255, 100, 100, 0.3)', targetVal: 1 }
 * ];
 *
 * const opts = {
 *   width: 600,
 *   height: 300,
 *   scales: { x: { time: false }, y: { min: 0, max: 6 } },
 *   axes: [{}, {}],
 *   series: [
 *     {}, // x axis
 *     { label: "Signal 1", stroke: "transparent" },
 *     { label: "Signal 2", stroke: "transparent" }
 *   ],
 *   plugins: [
 *     createDigitalFillPlugin(signals)
 *   ]
 * };
 *
 * const data = [xVals, signal1, signal2];
 * new uPlot(opts, data, document.getElementById("chart-digital"));
 */
export function createDigitalFillPlugin(signals) {
  // signals: [{signalIndex, offset, color, targetVal, originalIndex?}]
  const currentColors = signals.map((s) => s.color);
  const plugin = {
    id: "digitalFill",
    signals,
    getSignalColors() {
      // returns array [{ originalIndex, color }]
      return signals.map((sig, i) => ({
        originalIndex: sig.originalIndex ?? i,
        color: currentColors[i] || sig.color,
      }));
    },
    updateColors(newColors) {
      // newColors is expected as an array or object keyed by originalIndex
      signals.forEach((sig, i) => {
        const origIdx = sig.originalIndex ?? i;
        // support both array and object maps
        if (Array.isArray(newColors)) {
          if (typeof newColors[origIdx] !== "undefined")
            currentColors[i] = newColors[origIdx];
        } else if (newColors &amp;&amp; typeof newColors[origIdx] !== "undefined") {
          currentColors[i] = newColors[origIdx];
        }
      });
      return true;
    },
    // Allow external components to query the current colors
    getSignalColors() {
      return signals.map((sig, idx) => ({
        originalIndex: sig.originalIndex,
        color: currentColors[idx] || sig.color,
      }));
    },
    hooks: {
      setScale: [
        (u, scaleKey, opts) => {
          // if (scaleKey !== 'y') return;
          const yScaleOpts = u?.opts?.scales?.y;
          u.setScale("y", { min: 0, max: 15, auto: false });
          if (
            yScaleOpts &amp;&amp;
            typeof yScaleOpts.min === "number" &amp;&amp;
            typeof yScaleOpts.max === "number"
          ) {
            const cur = u.scales.y;
            // Only set if not already correct
            if (
              cur.min !== yScaleOpts.min ||
              cur.max !== yScaleOpts.max ||
              cur.auto !== false
            ) {
              u.setScale("y", {
                min: yScaleOpts.min,
                max: yScaleOpts.max,
                auto: false,
              });
            }
          }
        },
      ],
      draw: [
        (u) => {
          const { ctx } = u;
          const xData = u.data[0];
          const n = xData.length;
          const yScale = u.scales.y;
          if (isNaN(yScale.min) || isNaN(yScale.max)) {
            console.warn(
              "yScale min/max not defined, cannot draw digital fills"
            );
          }

          // Get the plotting area boundaries to avoid drawing over axes/labels
          const left = u.bbox.left;
          const top = u.bbox.top;
          const right = u.bbox.left + u.bbox.width;
          const bottom = u.bbox.top + u.bbox.height;

          ctx.save();
          ctx.beginPath();
          ctx.rect(left, top, right - left, bottom - top);
          ctx.clip();
          ctx.closePath();

          signals.forEach((sig, idx) => {
            const yData = u.data[sig.signalIndex];
            ctx.save();
            // Use currentColors array if updated, fallback to signal color
            const fillColor = currentColors[idx] || sig.color;
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            let beginFill = false;
            let xWidthCount = 0;
            let xBegin = 0,
              yBegin = 0;

            // Calculate the minimum value in yData to determine offsetPresent.
            // If the minimum is even, use it; otherwise, use the next lower even number.
            const offsetCalc = Math.min(...yData);
            const offsetPresent =
              offsetCalc % 2 === 0 ? offsetCalc : offsetCalc - 1;

            // Determine the effective offset to use for drawing
            const effectiveOffset = sig.offset;

            // Initial point for the step plot
            const px0 = u.valToPos(xData[0], "x", true);
            const py = u.valToPos(
              yData[0] - offsetPresent + effectiveOffset,
              "y",
              true
            );
            ctx.moveTo(px0, py);

            // If the first value is high, prepare to begin filling
            if (yData[0] === sig.targetVal + offsetPresent) {
              beginFill = true;
              xBegin = px0;
              yBegin = py;
            }

            // Calculate width and height for fill rectangles
            const xWidth = Math.abs(
              u.valToPos(xData[1], "x", true) - u.valToPos(xData[0], "x", true)
            );
            const yHeight = Math.abs(
              u.valToPos(
                yData[0] + sig.targetVal + effectiveOffset,
                "y",
                true
              ) - u.valToPos(yData[0] + effectiveOffset, "y", true)
            );

            // Iterate through all data points to draw step lines and fill regions
            for (let i = 0; i &lt; n - 1; i++) {
              const x0 = u.valToPos(xData[i], "x", true);
              const x1 = u.valToPos(xData[i + 1], "x", true);
              const y = u.valToPos(
                yData[i] - offsetPresent + effectiveOffset,
                "y",
                true
              );
              const y1 = u.valToPos(
                yData[i + 1] - offsetPresent + effectiveOffset,
                "y",
                true
              );

              ctx.lineTo(x1, y);
              if (y !== y1) ctx.lineTo(x1, y1);

              // If the signal transitions from high to low, fill the region
              if (yData[i] != sig.targetVal + offsetPresent) {
                if (beginFill) {
                  ctx.fillRect(xBegin, yBegin, x0 - xBegin, yHeight);
                  ctx.stroke();
                }
                beginFill = false;
                xWidthCount = 0;
              }
              // If the signal is high, start or continue filling
              if (yData[i] == sig.targetVal + offsetPresent) {
                if (!beginFill) {
                  beginFill = true;
                  xBegin = x0;
                  yBegin = y;
                }
                xWidthCount++;
                // If this is the last point, fill to the end
                if (i === n - 2) {
                  ctx.fillRect(xBegin, yBegin, x1 - xBegin, yHeight);
                  ctx.stroke();
                }
              }
            }
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
          });
          ctx.restore(); // Remove the clip
        },
      ],
    },
  };
  return plugin;
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
