

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> main.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-analyzeGroupsAndPublish.html">analyzeGroupsAndPublish</a></li><li><a href="module-axisBuilder.html">axisBuilder</a></li><li><a href="module-axisCalculator.html">axisCalculator</a></li><li><a href="module-calculateAndPublishMaxYAxes.html">calculateAndPublishMaxYAxes</a></li><li><a href="module-chartAxisAlignment.html">chartAxisAlignment</a></li><li><a href="module-chartComponent.html">chartComponent</a></li><li><a href="module-chartDomUtils.html">chartDomUtils</a></li><li><a href="module-chartManager.html">chartManager</a></li><li><a href="module-comtradeUtils.html">comtradeUtils</a></li><li><a href="module-createDragBar.html">createDragBar</a></li><li><a href="module-createState.html">createState</a></li><li><a href="module-domUpdateQueue.html">domUpdateQueue</a></li><li><a href="module-domUpdateQueueInit.html">domUpdateQueueInit</a></li><li><a href="module-handleVerticalLineShortcuts.html">handleVerticalLineShortcuts</a></li><li><a href="module-initVerticalLineControl.html">initVerticalLineControl</a></li><li><a href="module-main.html">main</a></li><li><a href="module-maxYAxesStore.html">maxYAxesStore</a></li><li><a href="module-mergerWindowLauncher.html">mergerWindowLauncher</a></li><li><a href="module-performanceMonitor.html">performanceMonitor</a></li><li><a href="module-seriesMapper.html">seriesMapper</a></li><li><a href="module-setupChartDragAndDrop.html">setupChartDragAndDrop</a></li><li><a href="module-timeInterpolation.html">timeInterpolation</a></li><li><a href="module-verticalLineControl.html">verticalLineControl</a></li></ul><h3>Classes</h3><ul><li><a href="ComputedChannelMetadata.html">ComputedChannelMetadata</a></li><li><a href="PolarChart.html">PolarChart</a></li><li><a href="module-performanceMonitor-PhaseTracker.html">PhaseTracker</a></li></ul><h3>Global</h3><ul><li><a href="global.html#IMPLEMENTATION_COMPLETE">IMPLEMENTATION_COMPLETE</a></li><li><a href="global.html#QUICK_REFERENCE">QUICK_REFERENCE</a></li><li><a href="global.html#STORAGE_KEY">STORAGE_KEY</a></li><li><a href="global.html#THEMES">THEMES</a></li><li><a href="global.html#applyTheme">applyTheme</a></li><li><a href="global.html#autoGroupChannels">autoGroupChannels</a></li><li><a href="global.html#calculateStats">calculateStats</a></li><li><a href="global.html#chart2">chart2</a></li><li><a href="global.html#clearCaches">clearCaches</a></li><li><a href="global.html#clearChartsContainer">clearChartsContainer</a></li><li><a href="global.html#clearComputedChannelsFromStorage">clearComputedChannelsFromStorage</a></li><li><a href="global.html#clearExpressionCache">clearExpressionCache</a></li><li><a href="global.html#collectChartDeltas">collectChartDeltas</a></li><li><a href="global.html#convertLatexToMathJs">convertLatexToMathJs</a></li><li><a href="global.html#convertLatexToPlainText">convertLatexToPlainText</a></li><li><a href="global.html#createAnalogChannelGroupMap">createAnalogChannelGroupMap</a></li><li><a href="global.html#createBinaryBlob">createBinaryBlob</a></li><li><a href="global.html#createChannelItem">createChannelItem</a></li><li><a href="global.html#createChannelList">createChannelList</a></li><li><a href="global.html#createChartContainer">createChartContainer</a></li><li><a href="global.html#createChartOptions">createChartOptions</a></li><li><a href="global.html#createComputedChannelsLabels">createComputedChannelsLabels</a></li><li><a href="global.html#createComputedChannelsSidebar">createComputedChannelsSidebar</a></li><li><a href="global.html#createDebouncedRender">createDebouncedRender</a></li><li><a href="global.html#createDeltaWindow">createDeltaWindow</a></li><li><a href="global.html#createDigitalFillPlugin">createDigitalFillPlugin</a></li><li><a href="global.html#createScopeTemplate">createScopeTemplate</a></li><li><a href="global.html#createSimpleChannelList">createSimpleChannelList</a></li><li><a href="global.html#createSimpleContainer">createSimpleContainer</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createTooltip">createTooltip</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#encodeFloat64">encodeFloat64</a></li><li><a href="global.html#encodeInt32">encodeInt32</a></li><li><a href="global.html#evaluateAndSaveComputedChannel">evaluateAndSaveComputedChannel</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#exportAllChannelsAsCSV">exportAllChannelsAsCSV</a></li><li><a href="global.html#exportAllComputedChannels">exportAllComputedChannels</a></li><li><a href="global.html#exportAsASCII">exportAsASCII</a></li><li><a href="global.html#exportComputedChannelAsASCII">exportComputedChannelAsASCII</a></li><li><a href="global.html#exportComputedChannelAsCFGDAT">exportComputedChannelAsCFGDAT</a></li><li><a href="global.html#exportComputedChannelsAsCSV">exportComputedChannelsAsCSV</a></li><li><a href="global.html#formatEquationForLatex">formatEquationForLatex</a></li><li><a href="global.html#generateCFGContent">generateCFGContent</a></li><li><a href="global.html#generateCFGContentBatch">generateCFGContentBatch</a></li><li><a href="global.html#generateCFGContentBinary32">generateCFGContentBinary32</a></li><li><a href="global.html#generateCFGContentBinary64">generateCFGContentBinary64</a></li><li><a href="global.html#generateCFGContentFloat32">generateCFGContentFloat32</a></li><li><a href="global.html#generateCFGContentFloat64">generateCFGContentFloat64</a></li><li><a href="global.html#generateDATContent">generateDATContent</a></li><li><a href="global.html#generateDATContentBatch">generateDATContentBatch</a></li><li><a href="global.html#generateDATContentBinary32">generateDATContentBinary32</a></li><li><a href="global.html#generateDATContentBinary64">generateDATContentBinary64</a></li><li><a href="global.html#generateDATContentFloat32">generateDATContentFloat32</a></li><li><a href="global.html#generateDATContentFloat64">generateDATContentFloat64</a></li><li><a href="global.html#getAllAvailableGroups">getAllAvailableGroups</a></li><li><a href="global.html#getCacheStats">getCacheStats</a></li><li><a href="global.html#getChannelByDisplayName">getChannelByDisplayName</a></li><li><a href="global.html#getChannelMetadata">getChannelMetadata</a></li><li><a href="global.html#getChannelsForFile">getChannelsForFile</a></li><li><a href="global.html#getCompiledExpression">getCompiledExpression</a></li><li><a href="global.html#getComputedChannelStorageMetadata">getComputedChannelStorageMetadata</a></li><li><a href="global.html#getCurrentTheme">getCurrentTheme</a></li><li><a href="global.html#getCurrentThemeColors">getCurrentThemeColors</a></li><li><a href="global.html#getFileIndexForTime">getFileIndexForTime</a></li><li><a href="global.html#getMemoryInfo">getMemoryInfo</a></li><li><a href="global.html#getOriginalChannelName">getOriginalChannelName</a></li><li><a href="global.html#getSampleIndexInFile">getSampleIndexInFile</a></li><li><a href="global.html#getThemeColor">getThemeColor</a></li><li><a href="global.html#groupCfgDatFiles">groupCfgDatFiles</a></li><li><a href="global.html#hasStoredComputedChannels">hasStoredComputedChannels</a></li><li><a href="global.html#hideTooltip">hideTooltip</a></li><li><a href="global.html#importComputedChannelFromJSON">importComputedChannelFromJSON</a></li><li><a href="global.html#initTheme">initTheme</a></li><li><a href="global.html#initUPlotChart">initUPlotChart</a></li><li><a href="global.html#initializeSidebarChannels">initializeSidebarChannels</a></li><li><a href="global.html#injectSidebarIntoUplot">injectSidebarIntoUplot</a></li><li><a href="global.html#loadComputedChannelsFromStorage">loadComputedChannelsFromStorage</a></li><li><a href="global.html#measurePerformance">measurePerformance</a></li><li><a href="global.html#mergeAnalogChannels">mergeAnalogChannels</a></li><li><a href="global.html#mergeComtradeFilesSetsSequential">mergeComtradeFilesSetsSequential</a></li><li><a href="global.html#mergeDigitalChannels">mergeDigitalChannels</a></li><li><a href="global.html#mergeTimeArraysSequential">mergeTimeArraysSequential</a></li><li><a href="global.html#openMathLiveEditor">openMathLiveEditor</a></li><li><a href="global.html#performExport">performExport</a></li><li><a href="global.html#processFilesInBatches">processFilesInBatches</a></li><li><a href="global.html#processInChunks">processInChunks</a></li><li><a href="global.html#renameChannelWithPrefix">renameChannelWithPrefix</a></li><li><a href="global.html#renderComputedChannels">renderComputedChannels</a></li><li><a href="global.html#renderComtradeCharts">renderComtradeCharts</a></li><li><a href="global.html#saveComputedChannelToGlobals">saveComputedChannelToGlobals</a></li><li><a href="global.html#saveComputedChannelsToStorage">saveComputedChannelsToStorage</a></li><li><a href="global.html#separateComputedFiles">separateComputedFiles</a></li><li><a href="global.html#setupMobileSidebar">setupMobileSidebar</a></li><li><a href="global.html#setupPolarChartWithVerticalLines">setupPolarChartWithVerticalLines</a></li><li><a href="global.html#showChannelListWindow">showChannelListWindow</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#showExportFormatDialog">showExportFormatDialog</a></li><li><a href="global.html#showFileInfo">showFileInfo</a></li><li><a href="global.html#sortFilePairs">sortFilePairs</a></li><li><a href="global.html#subscribeChartUpdates">subscribeChartUpdates</a></li><li><a href="global.html#toggleChartsVisibility">toggleChartsVisibility</a></li><li><a href="global.html#toggleTheme">toggleTheme</a></li><li><a href="global.html#updateComputedChannelsSidebar">updateComputedChannelsSidebar</a></li><li><a href="global.html#updateFileInfo">updateFileInfo</a></li><li><a href="global.html#updateStatsCards">updateStatsCards</a></li><li><a href="global.html#updateTooltip">updateTooltip</a></li><li><a href="global.html#validateSampleRates">validateSampleRates</a></li><li><a href="global.html#wrapChartInSection">wrapChartInSection</a></li><li><a href="global.html#yieldToEventLoop">yieldToEventLoop</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>main.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  createChartOptions,
  updateAllChartAxisColors,
} from "./components/chartComponent.js";
import { parseCFG, parseDAT } from "./components/comtradeUtils.js";
import { createState } from "./components/createState.js";
import {
  processFilesInBatches,
  yieldToEventLoop,
} from "./utils/batchFileProcessor.js";
import {
  calculateDeltas,
  collectChartDeltas,
} from "./utils/calculateDeltas.js";
import { createDeltaWindow } from "./components/DeltaWindow.js";
import { createDragBar } from "./components/createDragBar.js";
import { setupChartDragAndDrop } from "./components/setupChartDragAndDrop.js";
import { handleVerticalLineShortcuts } from "./components/handleVerticalLineShortcuts.js";
import { showError } from "./components/showError.js";
import { renderComtradeCharts } from "./components/renderComtradeCharts.js";
import { renderComputedChannels } from "./components/renderComputedChannels.js";
import { ResizableGroup } from "./components/ResizableGroup.js";
import { showChannelListWindow } from "./components/showChannelListWindow.js";
import { createChannelList } from "./components/ChannelList.js";
import { createCustomElement } from "./utils/helpers.js";
import { analogPalette, digitalPalette } from "./utils/constants.js";
import { subscribeChartUpdates } from "./components/chartManager.js";
import { debugLite } from "./components/debugPanelLite.js";
import { autoGroupChannels } from "./utils/autoGroupChannels.js";
import { initVerticalLineControl } from "./components/initVerticalLineControl.js";
import { debounce } from "./utils/computedChannelOptimization.js";
import {
  exportComputedChannelAsASCII,
  importComputedChannelFromJSON,
  exportComputedChannelAsCFGDAT,
  exportAllComputedChannels,
} from "./components/EquationEvaluatorInChannelList.js";
import {
  showFileInfo,
  updateStatsCards,
  wrapChartInSection,
  updateFileInfo,
  toggleChartsVisibility,
  clearChartsContainer,
} from "./utils/uiHelpers.js";
import { exportComputedChannelsAsCSV } from "./utils/csvExport.js";
import {
  saveComputedChannelsToStorage,
  loadComputedChannelsFromStorage,
} from "./utils/computedChannelStorage.js";
import { PolarChart } from "./components/PolarChart.js";
import { setupPolarChartWithVerticalLines } from "./components/setupPolarChartIntegration.js";
import {
  initTheme,
  toggleTheme,
  getCurrentTheme,
} from "./utils/themeManager.js";
import { initGlobalDOMUpdateQueue } from "./utils/domUpdateQueueInit.js";
import { openMergerWindow } from "./utils/mergerWindowLauncher.js";

// Initialize global DOM update queue for selectiveUpdate feature
initGlobalDOMUpdateQueue();

/**
 * @file main.js - Core application logic and parent-child window messaging
 * @module main
 * @description
 * This module handles COMTRADE file loading, chart initialization, and manages
 * communication between the parent window and child popup (ChannelList).
 *
 * Message Flow:
 * Child Window (Tabulator) â†’ Parent Window â†’ channelState update â†’ Chart subscribers triggered
 */
/**
 * Channel row structure received from the ChannelList popup (Tabulator).
 * Copied here for JSDoc compatibility so JSDoc can resolve the type without
 * relying on `import()`-style type expressions which older JSDoc versions
 * do not accept.
 *
 * @typedef {Object} ChannelRow
 * @property {string} [type] - 'Analog' or 'Digital'
 * @property {number} [id] - 1-based table id
 * @property {number} [originalIndex] - zero-based original index when available
 * @property {string} [channelID] - stable channel identifier assigned by parent
 * @property {string} [name]
 * @property {string} [unit]
 * @property {string} [group]
 * @property {string} [color]
 * @property {number|string} [scale]
 * @property {number|string} [start]
 * @property {number|string} [duration]
 * @property {boolean} [invert]
 * @property {boolean} [isNew]
 */

/**
 * Child -> Parent message shape used by the ChannelList popup.
 *
 * @typedef {Object} ChildToParentMessage
 * @property {string} source - Should be 'ChildWindow'
 * @property {string} type - One of the CALLBACK_TYPE constants
 * @property {ChildMessagePayload} payload - The payload detailed below
 */

/**
 * Payload sent by the child window to the parent (Tabulator edits).
 * @typedef {Object} ChildMessagePayload
 * @property {string} [field]
 * @property {ChannelRow} [row]
 * @property {any} [newValue]
 * @property {string} [channelID]
 * @property {Array} [args]
 */

/**
 * Acknowledgement message posted back from parent -> child after channel add.
 * @typedef {Object} ParentAckMessage
 * @property {string} source - 'ParentWindow'
 * @property {string} type - 'ack_addChannel'
 * @property {Object} payload - { tempClientId, channelID, assignedIndex, type }
 */

// --- State ---
export const verticalLinesX = createState([]);
export const dataState = createState({ analog: [], digital: [] });

// Initialize delta display window
export const deltaWindow = createDeltaWindow();

// Export calculateDeltas utils for fast access
export { collectChartDeltas };

// Getter functions for global state
export function getCfg() {
  return cfg;
}

export function getData() {
  return data;
}

export function getPolarChart() {
  return polarChart;
}

let charts = [null, null]; // [analogChart, digitalChart]
const chartTypes = ["analog", "digital"];

// Expose charts globally for theme system to access
window.__charts = charts;

// Global config and data
let cfg, data;

// Polar chart instance (initialized when files are loaded)
let polarChart = null;

// Vertical Line Control instance (initialized when files are loaded)
let verticalLineControl = null;

// --- Constants ---
const TIME_UNIT = "seconds";

// Callback message types from child window
export const CALLBACK_TYPE = {
  COLOR: "callback_color",
  SCALE: "callback_scale",
  START: "callback_start",
  DURATION: "callback_duration",
  INVERT: "callback_invert",
  CHANNEL_NAME: "callback_channelName",
  GROUP: "callback_group",
  ADD_CHANNEL: "callback_addChannel",
  DELETE: "callback_delete",
};

/**
 * Find a channel by its unique channelID in the channel state
 *
 * @function findChannelByID
 * @category State Management / Channel Lookup
 * @since 1.0.0
 *
 * @description
 * Searches for a channel across both analog and digital channel arrays using
 * its stable channelID. Returns the channel type and array index if found.
 * Analog channels are searched first, followed by digital channels.
 *
 * @param {string} channelID - Unique identifier of the channel to find
 *
 * @returns {Object|null} Channel location object or null if not found
 * @returns {string} returns.type - Channel type: "analog" or "digital"
 * @returns {number} returns.idx - Zero-based index in the type-specific array
 *
 * @mermaid
 * flowchart TD
 *     A["Input channelID"] --> B{"channelID valid?"}
 *     B -->|No| C["Return null"]
 *     B -->|Yes| D["Search analog channelIDs"]
 *     D -->|Found| E["Return {type:'analog', idx}"]
 *     D -->|Not Found| F["Search digital channelIDs"]
 *     F -->|Found| G["Return {type:'digital', idx}"]
 *     F -->|Not Found| H["Return null"]
 *     style A fill:#E3F2FD,stroke:#1565C0,color:#000
 *     style E fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style G fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style C fill:#FFCDD2,stroke:#C62828,color:#000
 *     style H fill:#FFCDD2,stroke:#C62828,color:#000
 *
 * @example
 * // Finding an existing analog channel
 * const result = findChannelByID("analog-0-abc123");
 * // Returns: { type: "analog", idx: 0 }
 *
 * @example
 * // Finding a non-existent channel
 * const result = findChannelByID("invalid-id");
 * // Returns: null
 *
 * @example
 * // Using the result to update channel state
 * const found = findChannelByID("CH001");
 * if (found) {
 *   channelState[found.type].lineColors[found.idx] = "#ff0000";
 * }
 *
 * @algorithm
 * 1. Validate that channelID is provided
 * 2. Search in analog channels:
 *    - Use indexOf on channelState.analog.channelIDs
 *    - If found (index >= 0), return { type: "analog", idx }
 * 3. If not found in analog, search digital channels:
 *    - Use indexOf on channelState.digital.channelIDs
 *    - If found (index >= 0), return { type: "digital", idx }
 * 4. If not found in either array, return null
 *
 * @throws {TypeError} Does not throw, but returns null for invalid input
 *
 * @dependencies
 * - channelState.analog.channelIDs {string[]} - Array of analog channel IDs
 * - channelState.digital.channelIDs {string[]} - Array of digital channel IDs
 *
 * @testcase
 * Input: channelID = "analog-0-abc123" (exists at analog index 0)
 * Expected: { type: "analog", idx: 0 }
 *
 * @testcase
 * Input: channelID = "digital-2-xyz789" (exists at digital index 2)
 * Expected: { type: "digital", idx: 2 }
 *
 * @testcase
 * Input: channelID = "invalid-id-12345" (does not exist)
 * Expected: null
 *
 * @testcase
 * Input: channelID = null
 * Expected: null
 *
 * @testcase
 * Input: channelID = "" (empty string)
 * Expected: null
 *
 * @performance O(n) where n is the number of channels in the searched arrays
 *
 * @see {@link updateChannelFieldByID} - Uses this function to locate channels
 * @see {@link deleteChannelByID} - Uses this function to locate channels
 */
// âš¡ Fast lookup map for channelID -> {type, idx} (O(1) instead of O(n))
// Updated whenever channelIDs change
const channelIDMap = new Map();

/**
 * Rebuild the fast lookup map when channelIDs change
 * Should be called after any change to channelState.analog/digital.channelIDs
 */
function rebuildChannelIDMap() {
  channelIDMap.clear();

  // Map analog channels
  const analogIDs = channelState.analog?.channelIDs || [];
  analogIDs.forEach((id, idx) => {
    if (id) channelIDMap.set(id, { type: "analog", idx });
  });

  // Map digital channels
  const digitalIDs = channelState.digital?.channelIDs || [];
  digitalIDs.forEach((id, idx) => {
    if (id) channelIDMap.set(id, { type: "digital", idx });
  });
}

function findChannelByID(channelID) {
  if (!channelID) return null;

  // âš¡ Fast O(1) lookup using map instead of O(n) indexOf
  const result = channelIDMap.get(channelID);
  if (result) return result;

  // Fallback: rebuild map in case it's stale (safety net)
  rebuildChannelIDMap();
  return channelIDMap.get(channelID) || null;
}
/**
 * Update a specific field of a channel identified by its channelID
 *
 * @function updateChannelFieldByID
 * @category State Management / Channel Update
 * @since 1.0.0
 *
 * @description
 * High-level wrapper that locates a channel by its stable ID and updates
 * a specific field. This function automatically determines whether the channel
 * is analog or digital and delegates to updateChannelFieldByIndex for the
 * actual update. The reactive state system automatically notifies subscribers
 * after the update.
 *
 * @param {string} channelID - Unique identifier of the channel to update
 * @param {string} fieldName - Name of the field to update
 * @param {*} value - New value to set for the field
 *
 * @returns {boolean} true if update succeeded, false if channel not found
 *
 * @mermaid
 * flowchart TD
 *     A["Input channelID, fieldName, value"] --> B["Call findChannelByID"]
 *     B --> C{"Channel found?"}
 *     C -->|No| D["Log not-found and return false"]
 *     C -->|Yes| E["Extract type and index"]
 *     E --> F["Get channelState[type][fieldName]"]
 *     F --> G{"Array valid?"}
 *     G -->|No| D
 *     G -->|Yes| H["Update array[index] = value"]
 *     H --> I["Trigger subscribers"]
 *     I --> J["Log success and return true"]
 *     style A fill:#E3F2FD,stroke:#1565C0,color:#000
 *     style J fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style D fill:#FFCDD2,stroke:#C62828,color:#000
 *     style I fill:#F3E5F5,stroke:#6A1B9A,color:#fff
 *
 * @example
 * // Update channel color
 * const success = updateChannelFieldByID("analog-0-abc123", "lineColors", "#ff0000");
 * console.log(success); // true
 * // Result: Channel color updated, chart redraws automatically
 *
 * @example
 * // Update channel name
 * updateChannelFieldByID("digital-2-xyz789", "yLabels", "New Sensor Name");
 * // Result: Channel label updated, legend refreshes
 *
 * @example
 * // Update scale (triggers chart recreation)
 * updateChannelFieldByID("analog-1-def456", "scales", 2.5);
 * // Result: Scale factor changed, chart recreates with new data
 *
 * @example
 * // Attempting to update non-existent channel
 * const success = updateChannelFieldByID("invalid-id", "lineColors", "#00ff00");
 * console.log(success); // false
 * // Result: No changes made, debug log shows "not-found"
 *
 * @algorithm
 * 1. Call findChannelByID(channelID) to locate the channel
 * 2. If channel not found (result is null):
 *    - Log debug message with "not-found" status
 *    - Return false
 * 3. If channel found:
 *    - Extract type and index from result
 *    - Get the target array (channelState[type][fieldName])
 *    - Verify array exists
 *    - Update array[index] = value
 *    - Log debug message with success details
 *    - Return true
 * 4. Reactive state system automatically notifies subscribers
 *
 * @throws {TypeError} Does not throw, returns false on errors
 *
 * @dependencies
 * - findChannelByID() - To locate the channel
 * - channelState - Reactive state object containing channel data
 * - debugLite.log() - For debug logging (optional)
 *
 * @sideeffects
 * - Mutates channelState arrays directly
 * - Triggers reactive subscribers for the modified field
 * - May cause chart updates (redraw or recreation depending on field)
 * - Logs debug information to debugLite
 *
 * @testcase
 * Input: channelID="analog-0-abc", fieldName="lineColors", value="#ff0000"
 * Expected: Returns true, channelState.analog.lineColors[0] = "#ff0000"
 * Side Effect: Color subscriber triggered, chart series color updated
 *
 * @testcase
 * Input: channelID="digital-1-xyz", fieldName="inverts", value=true
 * Expected: Returns true, channelState.digital.inverts[1] = true
 * Side Effect: Invert subscriber triggered, data recalculated, chart recreated
 *
 * @testcase
 * Input: channelID="invalid-channel-id", fieldName="lineColors", value="#00ff00"
 * Expected: Returns false, no state changes
 * Side Effect: Debug log entry with "not-found" status
 *
 * @testcase
 * Input: channelID=null, fieldName="scales", value=2.0
 * Expected: Returns false (findChannelByID returns null)
 *
 * @performance O(n) for channel lookup, O(1) for update
 *
 * @see {@link findChannelByID} - Used internally for channel lookup
 * @see {@link updateChannelFieldByIndex} - Lower-level update function
 * @see {@link subscribeChartUpdates} - Handles subscriber notifications
 */
// Helper: update a named per-channel array (like 'inverts' or 'scales') by channelID
function updateChannelFieldByID(channelID, fieldName, value) {
  const found = findChannelByID(channelID);
  try {
    debugLite.log("updateByID.attempt", {
      channelID,
      field: found ? "found" : "not-found",
      fieldName,
      newValue: value,
    });
  } catch (e) {}
  if (!found) return false;
  const arr = channelState[found.type][fieldName];
  if (!Array.isArray(arr)) return false;
  arr[found.idx] = value;
  try {
    debugLite.log("updateByID.ok", {
      channelID,
      type: found.type,
      idx: found.idx,
      fieldName,
      newValue: value,
    });
  } catch (e) {}
  return true;
}

/**
 * Update a channel field using direct array index access
 *
 * @function updateChannelFieldByIndex
 * @category State Management / Direct Update
 * @since 1.0.0
 *
 * @description
 * Lower-level function that directly mutates channelState arrays using
 * numeric indices. This function performs defensive bounds checking and
 * ensures the target field array exists before updating. No channel ID
 * lookup is performed - the caller must provide the correct type and index.
 *
 * @param {string} type - Channel type: "analog" or "digital"
 * @param {number} idx - Zero-based array index
 * @param {string} fieldName - Field array name (e.g., "lineColors", "scales")
 * @param {*} value - New value to set
 *
 * @returns {boolean} true if update succeeded, false on validation failure
 *
 * @mermaid
 * flowchart TD
 *     A["Input type, index, fieldName, value"] --> B{"Type is analog or digital?"}
 *     B -->|No| B1["Return false"]
 *     B -->|Yes| C["Get channelState[type]"]
 *     C --> D{"Section exists?"}
 *     D -->|No| B1
 *     D -->|Yes| E["Ensure field array initialized"]
 *     E --> F["Get array reference"]
 *     F --> G{"Value is array?"}
 *     G -->|No| B1
 *     G -->|Yes| H["Convert idx to number"]
 *     H --> I{"Index finite and in range?"}
 *     I -->|No| B1
 *     I -->|Yes| J["Write value into array"]
 *     J --> K["Trigger subscribers"]
 *     K --> L["Return true"]
 *     style A fill:#E3F2FD,stroke:#1565C0,color:#000
 *     style L fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style B1 fill:#FFCDD2,stroke:#C62828,color:#000
 *     style K fill:#F3E5F5,stroke:#6A1B9A,color:#fff
 *
 * @example
 * // Update analog channel color by index
 * const success = updateChannelFieldByIndex("analog", 0, "lineColors", "#ff0000");
 * // Result: channelState.analog.lineColors[0] = "#ff0000"
 *
 * @example
 * // Update digital channel invert flag
 * updateChannelFieldByIndex("digital", 2, "inverts", true);
 * // Result: channelState.digital.inverts[2] = true, chart recreates
 *
 * @example
 * // Update scale factor
 * updateChannelFieldByIndex("analog", 1, "scales", 2.5);
 * // Result: channelState.analog.scales[1] = 2.5
 *
 * @example
 * // Invalid type - returns false
 * const success = updateChannelFieldByIndex("invalid", 0, "lineColors", "#fff");
 * console.log(success); // false
 *
 * @example
 * // Out of bounds index - returns false
 * const success = updateChannelFieldByIndex("analog", 999, "lineColors", "#fff");
 * console.log(success); // false
 *
 * @algorithm
 * 1. Validate type parameter:
 *    - Must be exactly "analog" or "digital"
 *    - Return false if invalid
 * 2. Get channelState section: s = channelState[type]
 *    - Return false if section doesn't exist
 * 3. Ensure target field array exists:
 *    - Initialize s[fieldName] as empty array if undefined
 *    - Return false if fieldName is not array after initialization
 * 4. Validate index:
 *    - Convert idx to number
 *    - Check: Number.isFinite(i) &amp;&amp; i >= 0 &amp;&amp; i &lt; arr.length
 *    - Log attempt via debugLite
 *    - Return false if validation fails
 * 5. Perform update:
 *    - arr[i] = value
 *    - Log success via debugLite
 *    - Return true
 *
 * @throws {TypeError} Does not throw, returns false for invalid inputs
 *
 * @dependencies
 * - channelState.analog - Analog channel state object
 * - channelState.digital - Digital channel state object
 * - debugLite.log() - Debug logging utility (optional, failures caught)
 *
 * @sideeffects
 * - Direct mutation of channelState arrays
 * - Triggers reactive subscribers for the field
 * - Chart updates depend on field type:
 *   - lineColors/yLabels â†’ in-place chart update
 *   - scales/inverts â†’ full chart recreation
 *   - starts/durations â†’ x-axis scale update
 *
 * @validation
 * This function validates:
 * - Type is "analog" or "digital"
 * - State section exists
 * - Index is finite number within bounds
 *
 * This function does NOT validate:
 * - Value type correctness (caller's responsibility)
 * - Field name validity (invalid names have no effect)
 *
 * @testcase
 * Input: type="analog", idx=0, fieldName="lineColors", value="#ff0000"
 * Expected: Returns true, lineColors[0] updated
 *
 * @testcase
 * Input: type="digital", idx=1, fieldName="inverts", value=true
 * Expected: Returns true, inverts[1] = true
 *
 * @testcase
 * Input: type="invalid", idx=0, fieldName="lineColors", value="#fff"
 * Expected: Returns false, no changes
 *
 * @testcase
 * Input: type="analog", idx=-1, fieldName="scales", value=2.0
 * Expected: Returns false (negative index)
 *
 * @testcase
 * Input: type="analog", idx=1000, fieldName="lineColors", value="#fff"
 * Expected: Returns false (index out of bounds)
 *
 * @testcase
 * Input: type="analog", idx=NaN, fieldName="scales", value=1.5
 * Expected: Returns false (non-finite index)
 *
 * @performance O(1) constant time operation
 *
 * @see {@link updateChannelFieldByID} - Higher-level wrapper using channelID
 * @see {@link subscribeChartUpdates} - Subscriber system that reacts to changes
 */
function updateChannelFieldByIndex(type, idx, fieldName, value) {
  const updateStartTime = performance.now();

  if (type !== "analog" &amp;&amp; type !== "digital") return false;
  const s = channelState[type];
  if (!s) return false;
  // ensure the target field exists and is an array
  s[fieldName] = s[fieldName] || [];
  const arr = s[fieldName];
  if (!Array.isArray(arr)) return false;
  const i = Number(idx);
  try {
    debugLite.log("updateByIndex.attempt", {
      type,
      idx: i,
      fieldName,
      newValue: value,
    });
  } catch (e) {}
  if (!Number.isFinite(i) || i &lt; 0 || i >= arr.length) return false;
  arr[i] = value;

  const updateEndTime = performance.now();
  const updateTime = updateEndTime - updateStartTime;
  if (updateTime > 10) {
    console.log(
      `[Performance] updateChannelFieldByIndex: ${fieldName} = ${value}`,
      {
        type,
        idx: i,
        timeMs: updateTime.toFixed(2),
      }
    );
  }

  try {
    debugLite.log("updateByIndex.ok", {
      type,
      idx: i,
      fieldName,
      newValue: value,
    });
  } catch (e) {}
  return true;
}

/**
 * Delete a channel completely from the system by its channelID
 *
 * @function deleteChannelByID
 * @category State Management / Channel Deletion
 * @since 1.0.0
 *
 * @description
 * Removes a channel from all related arrays in channelState, dataState, and
 * the raw data object. This ensures all arrays remain synchronized with the
 * same length. The operation is immediate and irreversible. After deletion,
 * reactive subscribers trigger and charts are automatically recreated with
 * the updated series list.
 *
 * @param {string} channelID - Unique identifier of channel to delete
 *
 * @returns {boolean} true if channel was found and deleted, false otherwise
 *
 * @mermaid
 * flowchart TD
 *     A["Input channelID"] --> B["Find channel with findChannelByID"]
 *     B --> C{"Channel exists?"}
 *     C -->|No| D["Return false; no change"]
 *     C -->|Yes| E["Extract type and index"]
 *     E --> F["List arrays that must stay in sync"]
 *     F --> G["Splice index from each array"]
 *     G --> H["Remove matching dataState series"]
 *     H --> I["Remove matching raw data series"]
 *     I --> J["Notify channelIDs subscribers"]
 *     J --> K["Charts rebuild without channel"]
 *     K --> L["Return true"]
 *     style A fill:#F44336,stroke:#B71C1C,color:#fff
 *     style D fill:#FFCDD2,stroke:#C62828,color:#000
 *     style L fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style G fill:#FFCCBC,stroke:#D84315,color:#000
 *     style J fill:#2196F3,stroke:#0D47A1,color:#fff
 *
 * @example
 * // Delete an existing analog channel
 * const success = deleteChannelByID("analog-0-abc123");
 * console.log(success); // true
 * // Result: Channel removed from all arrays, chart recreated without it
 *
 * @example
 * // Attempt to delete non-existent channel
 * const success = deleteChannelByID("invalid-channel-id");
 * console.log(success); // false
 * // Result: No changes made, function returns early
 *
 * @example
 * // Delete digital channel
 * deleteChannelByID("digital-2-xyz789");
 * // Result: Digital channel removed, digital chart recreated
 *
 * @algorithm
 * 1. Locate channel using findChannelByID(channelID)
 * 2. If not found (result is null):
 *    - Return false immediately
 * 3. If found, extract type and index from result
 * 4. Get state section: s = channelState[type]
 * 5. Define list of arrays that must be synchronized:
 *    - yLabels, lineColors, yUnits, groups, axesScales
 *    - scales, starts, durations, inverts, channelIDs
 * 6. For each array name in the list:
 *    - Check if s[name] exists and is array
 *    - If valid and index is in bounds: splice(index, 1)
 * 7. Remove corresponding series from dataState[type]:
 *    - Calculate seriesIdx = index + 1 (offset for time array)
 *    - Splice from dataState array
 * 8. Remove corresponding series from raw data[type]:
 *    - Calculate seriesIdx = index + 1
 *    - Splice from data array
 * 9. Reactive system notifies channelIDs subscribers
 * 10. Subscribers trigger chart recreation
 * 11. Return true
 *
 * @throws {TypeError} Does not throw, catches errors and continues
 *
 * @dependencies
 * - findChannelByID() - To locate the channel
 * - channelState - Reactive state with channel metadata
 * - dataState - Reactive state with chart data arrays
 * - data - Raw parsed data object
 *
 * @sideeffects
 * - Mutates multiple arrays in channelState[type]
 * - Mutates dataState[type] series array
 * - Mutates raw data[type] series array
 * - Triggers channelIDs subscriber (causes chart recreation)
 * - All arrays must remain synchronized (same length after deletion)
 *
 * @synchronization
 * Critical: All per-channel arrays must be kept in sync!
 * Before deletion (3 channels):
 * ```
 * channelIDs:   ["CH001", "CH002", "CH003"]
 * yLabels:      ["Temp1", "Temp2", "Temp3"]
 * lineColors:   ["#f00",  "#0f0",  "#00f"]
 * scales:       [1,       1,       2]
 * ```
 * After deleteChannelByID("CH002") (2 channels remain):
 * ```
 * channelIDs:   ["CH001", "CH003"]
 * yLabels:      ["Temp1", "Temp3"]
 * lineColors:   ["#f00",  "#00f"]
 * scales:       [1,       2]
 * ```
 *
 * @testcase
 * Input: channelID = "analog-1-abc" (exists at index 1 of 3 channels)
 * Expected: Returns true
 * State Before: yLabels=["A","B","C"], lineColors=["#f00","#0f0","#00f"]
 * State After: yLabels=["A","C"], lineColors=["#f00","#00f"]
 * Side Effect: Chart recreated with 2 series
 *
 * @testcase
 * Input: channelID = "invalid-id"
 * Expected: Returns false
 * State: No changes to any arrays
 *
 * @testcase
 * Input: channelID = "digital-0-xyz" (last remaining digital channel)
 * Expected: Returns true
 * State After: All digital arrays become empty []
 * Side Effect: Digital chart recreated with no series
 *
 * @testcase
 * Input: channelID = null
 * Expected: Returns false (findChannelByID returns null)
 *
 * @testcase
 * Input: channelID = ""
 * Expected: Returns false (findChannelByID returns null)
 *
 * @performance O(n*m) where n = number of arrays, m = array length
 *
 * @warnings
 * âš ï¸ This operation is IRREVERSIBLE - no undo functionality
 * âš ï¸ All arrays must be kept in sync - missing splice causes corruption
 * âš ï¸ Chart will be completely recreated (expensive operation)
 *
 * @see {@link findChannelByID} - Used to locate the channel
 * @see {@link subscribeChartUpdates} - Handles post-deletion chart recreation
 * @see {@link CALLBACK_TYPE.DELETE} - Message type that triggers this function
 */
// Helper: delete a channel by channelID (splice same arrays as delete-by-index)
function deleteChannelByID(channelID) {
  const found = findChannelByID(channelID);
  if (!found) return false;
  const s = channelState[found.type];
  const i = found.idx;

  // Arrays that must remain in sync for each channel
  const perChannelArrays = [
    "yLabels",
    "lineColors",
    "yUnits",
    "groups",
    "axesScales",
    "scales",
    "starts",
    "durations",
    "inverts",
    "channelIDs",
  ];

  perChannelArrays.forEach((name) => {
    if (s[name] &amp;&amp; Array.isArray(s[name])) {
      if (i >= 0 &amp;&amp; i &lt; s[name].length) s[name].splice(i, 1);
    }
  });

  // Also remove the placeholder series from dataState and original data to keep series alignment.
  try {
    const dtype = found.type;
    const arr = dataState &amp;&amp; dataState[dtype];
    const raw = data &amp;&amp; data[dtype];
    // series arrays start at index 1 (0 is time)
    const seriesIdx = i + 1;
    if (Array.isArray(arr) &amp;&amp; seriesIdx >= 1 &amp;&amp; seriesIdx &lt; arr.length) {
      arr.splice(seriesIdx, 1);
    }
    if (raw &amp;&amp; Array.isArray(raw) &amp;&amp; seriesIdx >= 1 &amp;&amp; seriesIdx &lt; raw.length) {
      raw.splice(seriesIdx, 1);
    }
  } catch (e) {
    // non-fatal
  }

  return true;
}

// Channel state for analog/digital
export const channelState = createState({
  analog: {
    yLabels: [],
    lineColors: [],
    yUnits: [],
    groups: [],
    axesScales: [],
    // per-channel parameters managed by ChannelList
    scales: [],
    starts: [],
    durations: [],
    inverts: [],
    xLabel: "",
    xUnit: "",
  },
  digital: {
    yLabels: [],
    lineColors: [],
    yUnits: [],
    groups: [],
    axesScales: [],
    // per-channel parameters managed by ChannelList
    scales: [],
    starts: [],
    durations: [],
    inverts: [],
    xLabel: "",
    xUnit: "",
  },
});

// Small runtime helper to inspect key runtime structures from DevTools.
// Call `window.__inspectComtradeState()` in the console to print `data`,
// `dataState`, `channelState`, and `charts` (safe, non-destructive).
try {
  if (typeof window !== "undefined") {
    window.__inspectComtradeState = function () {
      try {
        console.groupCollapsed("__inspectComtradeState");
        console.log(
          "data (module):",
          typeof data !== "undefined" ? data : null
        );
        console.log(
          "dataState (module):",
          typeof dataState !== "undefined" ? dataState : null
        );
        console.log(
          "channelState (module):",
          typeof channelState !== "undefined" ? channelState : null
        );
        try {
          console.log(
            "charts (module):",
            typeof charts !== "undefined" ? charts : null
          );
          if (Array.isArray(charts)) {
            charts.forEach((c, i) => {
              try {
                const xArr = c &amp;&amp; c.data &amp;&amp; c.data[0] ? c.data[0] : undefined;
                console.log(
                  `chart[${i}] x-array (first 10):`,
                  xArr &amp;&amp; xArr.slice ? xArr.slice(0, 10) : xArr
                );
              } catch (e) {}
            });
          }
        } catch (e) {}
        console.groupEnd();
      } catch (err) {
        console.error("__inspectComtradeState failed:", err);
      }
    };
  }
} catch (e) {}

// Friendly property aliases so callers can subscribe using business names
export const PROPERTY_ALIASES = {
  color: "lineColors",
  name: "yLabels",
  scale: "scales",
  start: "starts",
  duration: "durations",
  invert: "inverts",
  // allow subscribing directly to channelIDs array if desired
  channelIDs: "channelIDs",
  group: "groups",
};

// Convenience helper: subscribe to a logical property across both analog and digital
// Usage: channelState.subscribeProperty('color', handler, { descendants: true })
// The handler receives the same change object emitted by createState
channelState.subscribeProperty = function (propName, fn, options = {}) {
  const mapped = PROPERTY_ALIASES[propName] || propName;
  try {
    // subscribe to analog.&lt;mapped> and digital.&lt;mapped>
    this.subscribe(fn, {
      path: `analog.${mapped}`,
      descendants: !!options.descendants,
    });
    this.subscribe(fn, {
      path: `digital.${mapped}`,
      descendants: !!options.descendants,
    });
  } catch (e) {
    console.warn("subscribeProperty failed:", e);
  }
};

// Background mode: 0 = white, 1 = dark
export const whiteBackground = createState(0);

// --- DOM Elements ---
const cfgFileInput = document.getElementById("cfgFile");
const loadBtn = document.getElementById("loadBtn");
const cfgFileNameEl = document.getElementById("cfgFileName");
const datFileNameEl = document.getElementById("datFileName");
const chartsContainer = document.getElementById("charts");
const fixedResultsEl = document.getElementById("fixed-results");

console.log("[main.js] DOM Elements:", {
  loadBtn,
  cfgFileInput,
  chartsContainer,
});

// Global error capture so runtime crashes are visible in the app UI
window.addEventListener("error", (ev) => {
  try {
    const msg = `Error: ${ev.message} at ${ev.filename}:${ev.lineno}:${ev.colno}`;
    console.error(msg, ev.error);
    if (fixedResultsEl)
      fixedResultsEl.textContent =
        msg + "\n" + (ev.error &amp;&amp; ev.error.stack ? ev.error.stack : "");
  } catch (e) {
    console.error("Error handler failed", e);
  }
});
window.addEventListener("unhandledrejection", (ev) => {
  try {
    const msg = `UnhandledRejection: ${
      ev.reason &amp;&amp; ev.reason.message ? ev.reason.message : String(ev.reason)
    }`;
    console.error(msg, ev.reason);
    if (fixedResultsEl)
      fixedResultsEl.textContent =
        msg + "\n" + (ev.reason &amp;&amp; ev.reason.stack ? ev.reason.stack : "");
  } catch (e) {
    console.error("Rejection handler failed", e);
  }
});

// --- Event Listeners ---
loadBtn.addEventListener("click", handleLoadFiles);
console.log("[main.js] loadBtn event listener attached");

// Merge Multiple Files button
const mergeMultipleFilesBtn = document.getElementById("mergeMultipleFilesBtn");
if (mergeMultipleFilesBtn) {
  mergeMultipleFilesBtn.addEventListener("click", () => {
    console.log("[main.js] Opening COMTRADE File Merger...");
    openMergerWindow();
  });
  console.log("[main.js] mergeMultipleFilesBtn event listener attached");
}

// Listen for merged files from the merger app
window.addEventListener("mergedFilesReceived", async (event) => {
  console.log(
    "[main.js] ðŸ“¦ Received merged files from merger app:",
    event.detail
  );

  try {
    const { cfg: cfgData, datContent, filenames, fileCount, isMerged } =
      event.detail;

    if (!cfgData || !datContent) {
      showError("Invalid merged file data received from merger app.", fixedResultsEl);
      return;
    }

    // Show loading indicator
    fixedResultsEl.innerHTML =
      '&lt;div style="padding: 20px; text-align: center; color: var(--text-secondary);">&lt;p>ðŸ”„ Loading merged files...&lt;/p>&lt;p style="font-size: 0.9rem; margin-top: 10px;">Processing merged COMTRADE data&lt;/p>&lt;/div>';

    console.log("[main.js] ðŸ“Š PHASE 1: Parsing merged data");

    // Parse the merged CFG and DAT data
    // cfgData is already parsed from the merger app
    cfg = cfgData;

    // Parse the DAT content
    // The merger app should provide datContent as string or already parsed
    // If it's a string, we need to parse it
    let datData;
    if (typeof datContent === "string") {
      // Parse the DAT file - use the file type from CFG, default to ASCII
      const fileType = cfg.ft || "ASCII";
      console.log(`[main.js] Parsing merged DAT content as ${fileType} format`);
      datData = parseDAT(datContent, cfg, fileType, TIME_UNIT);
    } else {
      datData = datContent;
    }

    data = {
      ...datData,
      time: datData.time || [],
      analogData: datData.analogData || [],
      digitalData: datData.digitalData || [],
    };

    if (!data.time || data.time.length === 0) {
      showError("Failed to parse merged COMTRADE data.", fixedResultsEl);
      return;
    }

    console.log("[main.js] ðŸ“Š PHASE 2: Initializing data state");

    // Update global data state
    dataState.analog = data.analogData;
    dataState.digital = data.digitalData;

    // Update UI with filenames
    const filenameText = isMerged
      ? `Merged: ${filenames.join(", ")}`
      : `Loaded: ${filenames[0]}`;

    cfgFileNameEl.textContent = filenameText;
    datFileNameEl.textContent = isMerged
      ? `(${fileCount} DAT files merged)`
      : `DAT File: ${filenames[0]}.dat`;

    const groups = autoGroupChannels(cfg.analogChannels);

    // ===== UI HELPER CALLS (Light) =====
    showFileInfo();
    updateFileInfo(
      filenames[0],
      isMerged ? `${fileCount} files merged` : `${filenames[0]}.dat`
    );
    updateStatsCards({
      sampleRate: cfg.sampleRate || 4800,
      duration: cfg.duration || 2000,
      analogChannels: cfg.analogChannels,
      digitalChannels: cfg.digitalChannels,
    });
    toggleChartsVisibility(true);

    console.log("[main.js] ðŸŽ¨ PHASE 3: Channel state initialization");

    // PHASE 3: Initialize channel state
    if (channelState &amp;&amp; channelState.suspendHistory)
      channelState.suspendHistory();
    try {
      initializeChannelState(cfg, data);

      // Populate group IDs from autoGroupChannels results
      const analogGroupIds = new Array(cfg.analogChannels.length);
      groups.forEach((group) => {
        group.indices.forEach((channelIdx) => {
          analogGroupIds[channelIdx] = group.groupId;
        });
      });
      channelState.analog.groups = analogGroupIds;
      console.log(
        "[main.js] âœ… Populated analog group IDs from merged files:",
        analogGroupIds
      );
    } finally {
      if (channelState &amp;&amp; channelState.resumeHistory)
        channelState.resumeHistory();
    }

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[main.js] ðŸ“ˆ PHASE 4: Chart rendering");

    // PHASE 4: Render all charts
    renderComtradeCharts(
      cfg,
      data,
      chartsContainer,
      charts,
      verticalLinesX,
      createState,
      calculateDeltas,
      TIME_UNIT,
      channelState
    );

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[main.js] ðŸŽ¯ PHASE 5: Polar chart initialization");

    // PHASE 5: Initialize Polar Chart
    try {
      console.log("[main.js] Creating PolarChart instance...");
      polarChart = new PolarChart("polarChartContainer");
      polarChart.init();

      if (window.requestIdleCallback) {
        window.requestIdleCallback(
          () => {
            try {
              console.log("[PolarChart] Background: Updating phasor data...");
              polarChart.updatePhasorAtTimeIndex(cfg, data, 0);
              console.log("[PolarChart] âœ… Background phasor update complete");
            } catch (err) {
              console.error("[PolarChart] Background update failed:", err);
            }
          },
          { timeout: 2000 }
        );
      } else {
        requestAnimationFrame(() => {
          setTimeout(() => {
            try {
              console.log("[PolarChart] Fallback: Updating phasor data...");
              polarChart.updatePhasorAtTimeIndex(cfg, data, 0);
            } catch (err) {
              console.error("[PolarChart] Fallback update failed:", err);
            }
          }, 100);
        });
      }

      console.log(
        "[main.js] âœ… Polar chart instance created (rendering deferred)"
      );
    } catch (err) {
      console.error(
        "[main.js] âŒ Failed to initialize polar chart:",
        err.message
      );
    }

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[main.js] ðŸ“Ÿ PHASE 6: Computed channels");

    // PHASE 6: Load persisted computed channels
    const savedChannels = loadComputedChannelsFromStorage();
    if (savedChannels.length > 0) {
      if (!data.computedData) data.computedData = [];
      for (const savedChannel of savedChannels) {
        const exists = data.computedData.some(
          (ch) => ch.equation === savedChannel.expression
        );
        if (!exists) {
          data.computedData.push({
            id: savedChannel.name,
            equation: savedChannel.expression,
            data: savedChannel.data,
            index: data.computedData.length,
          });
        }
      }
      if (data.computedData.length > 0) {
        const exportBtn = document.getElementById("exportComputedChannelBtn");
        const csvBtn = document.getElementById("exportCSVBtn");
        if (exportBtn) exportBtn.disabled = false;
        if (csvBtn) csvBtn.disabled = false;
        renderComputedChannels(
          data,
          chartsContainer,
          charts,
          verticalLinesX,
          channelState
        );
      }
    }
    setupComputedChannelsListener();

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[main.js] ðŸ”— PHASE 7: Chart integrations");

    // PHASE 7: Setup polar chart with vertical lines
    if (polarChart) {
      try {
        setupPolarChartWithVerticalLines(
          polarChart,
          cfg,
          data,
          verticalLinesX,
          charts
        );
        console.log("[main.js] âœ… Polar chart integrated");
      } catch (err) {
        console.error(
          "[main.js] âŒ Polar chart integration failed:",
          err.message
        );
      }
    }

    // PHASE 8: Final setup
    try {
      applyInitialStartDurations(channelState, dataState, charts);
    } catch (e) {
      console.debug("applyInitialStartDurations failed:", e);
    }

    try {
      const maxDuration = data.time ? data.time[data.time.length - 1] : 1;
      verticalLineControl = initVerticalLineControl({
        dataState: dataState,
        maxDuration: maxDuration,
        onPositionChange: (value) => {
          // Vertical line position changed
        },
      });
    } catch (error) {
      console.error(
        "[main.js] Failed to initialize vertical line control:",
        error
      );
    }

    if (window._resizableGroup) window._resizableGroup.disconnect();
    window._resizableGroup = new ResizableGroup(".dragBar");

    // Initialize fast lookup map
    rebuildChannelIDMap();

    // Setup subscriptions
    try {
      channelState.analog?.subscribe?.(() => {
        rebuildChannelIDMap();
      });
      channelState.digital?.subscribe?.(() => {
        rebuildChannelIDMap();
      });
    } catch (e) {
      console.warn("[main] Failed to set up channelID map rebuild:", e);
    }

    // Defer subscription setup
    if (window.requestIdleCallback) {
      window.requestIdleCallback(
        () => {
          console.log(
            "[main.js] Background: Setting up chart subscriptions..."
          );
          subscribeChartUpdates(
            channelState,
            dataState,
            charts,
            chartsContainer,
            verticalLinesX,
            cfg,
            data,
            createState,
            calculateDeltas,
            TIME_UNIT
          );
          console.log("[main.js] âœ… Chart subscriptions ready");
        },
        { timeout: 2000 }
      );
    } else {
      setTimeout(() => {
        subscribeChartUpdates(
          channelState,
          dataState,
          charts,
          chartsContainer,
          verticalLinesX,
          cfg,
          data,
          createState,
          calculateDeltas,
          TIME_UNIT
        );
      }, 500);
    }

    console.log(
      "[main.js] ðŸŽ‰ COMPLETE - All merged files loaded and rendered successfully"
    );
    fixedResultsEl.innerHTML = "";
  } catch (error) {
    console.error("[main.js] âŒ Error processing merged files:", error.message);
    showError(
      "An error occurred while processing the merged COMTRADE files. Check the console for details.",
      fixedResultsEl
    );
  }
});
console.log("[main.js] mergedFilesReceived event listener attached");

// Sidebar Toggle Functionality
const sidebar = document.getElementById("sidebar");
const closeSidebarBtn = document.getElementById("closeSidebarBtn");
const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
const mainContent = document.querySelector("main");
const floatingWindowBtn = document.getElementById("floatingWindowBtn");
const belowChartBtn = document.getElementById("belowChartBtn");
const returnSidebarBtn = document.getElementById("returnSidebarBtn");
const returnSidebarFromBelowBtn = document.getElementById(
  "returnSidebarFromBelowBtn"
);
const detachedWindow = document.getElementById("detachedWindow");
const windowTitleBar = document.getElementById("windowTitleBar");
const attachWindowBtn = document.getElementById("attachWindowBtn");
const closeWindowBtn = document.getElementById("closeWindowBtn");
const detachedWindowContent = document.getElementById("detachedWindowContent");

// Create analysis container for detached sidebar in charts area
let analysisContainer = null;
function getOrCreateAnalysisContainer() {
  if (!analysisContainer) {
    analysisContainer = document.createElement("div");
    analysisContainer.id = "analysis-sidebar-container";
    analysisContainer.style.background = "var(--bg-secondary)";
    analysisContainer.style.border = "1px solid var(--border-color)";
    analysisContainer.style.borderRadius = "var(--border-radius-sm)";
    analysisContainer.style.padding = "16px";
    analysisContainer.style.marginTop = "16px";
  }
  return analysisContainer;
}

// Track current sidebar layout mode
let sidebarLayoutMode = "sidebar"; // "sidebar", "floating", "charts-inline", "charts-below", or "analysis-container"

// Dragging variables
let isDragging = false;
let dragOffsetX = 0;
let dragOffsetY = 0;

// Helper function to move polar chart section to different locations
function movePolarChartSection(targetMode) {
  const polarChartSection = document.querySelector(".polar-chart-section");
  if (!polarChartSection) return;

  switch (targetMode) {
    case "floating":
      // Move to floating window
      detachedWindowContent.innerHTML = polarChartSection.innerHTML;
      detachedWindow.classList.add("show");
      sidebar.style.display = "none";
      sidebarToggleBtn.style.display = "flex";
      if (mainContent) mainContent.classList.add("sidebar-closed");
      console.log("[main.js] Sidebar moved to floating window");
      break;

    case "charts-inline":
      // Move to charts container (side by side)
      const chartsGrid =
        document.querySelector(".charts-grid") ||
        chartsContainer.querySelector(".uplot-container");
      if (chartsContainer) {
        // Store original content before moving
        chartsContainer.classList.remove("charts-block-layout");
        polarChartSection.style.order = "-1"; // Display first in charts container
        chartsContainer.style.display = "grid";
        chartsContainer.style.gridTemplateColumns = "1fr 1fr";
        chartsContainer.style.gap = "16px";
        chartsContainer.insertBefore(
          polarChartSection,
          chartsContainer.firstChild
        );
        sidebar.style.display = "none";
        sidebarToggleBtn.style.display = "flex";
        if (mainContent) mainContent.classList.add("sidebar-closed");
        console.log(
          "[main.js] Sidebar moved to charts container inline (side by side)"
        );
      }
      break;

    case "charts-below":
      // Move to charts container (below charts)
      if (chartsContainer) {
        // Reset order and append to end (below charts)
        chartsContainer.classList.add("charts-block-layout");
        polarChartSection.style.order = "auto";
        chartsContainer.style.display = "block";
        chartsContainer.style.gridTemplateColumns = "auto";
        chartsContainer.style.gap = "auto";
        chartsContainer.appendChild(polarChartSection);
        sidebar.style.display = "none";
        sidebarToggleBtn.style.display = "flex";
        if (mainContent) mainContent.classList.add("sidebar-closed");
        console.log("[main.js] Sidebar moved to charts container below");
      }
      break;

    case "analysis-container":
      // Move to dedicated analysis container in charts area
      if (chartsContainer) {
        const container = getOrCreateAnalysisContainer();
        if (!container.parentElement) {
          chartsContainer.appendChild(container);
        }

        // Create header with close button
        const headerDiv = document.createElement("div");
        headerDiv.style.display = "flex";
        headerDiv.style.justifyContent = "space-between";
        headerDiv.style.alignItems = "center";
        headerDiv.style.marginBottom = "12px";
        headerDiv.style.paddingBottom = "8px";
        headerDiv.style.borderBottom = "1px solid var(--border-color)";

        const titleSpan = document.createElement("span");
        titleSpan.textContent = "Analysis";
        titleSpan.style.fontWeight = "600";
        titleSpan.style.color = "var(--text-primary)";
        headerDiv.appendChild(titleSpan);

        const closeBtn = document.createElement("button");
        closeBtn.textContent = "â¬… Back";
        closeBtn.style.background = "none";
        closeBtn.style.border = "none";
        closeBtn.style.color = "var(--text-secondary)";
        closeBtn.style.cursor = "pointer";
        closeBtn.style.fontSize = "0.85rem";
        closeBtn.style.padding = "4px 8px";
        closeBtn.style.borderRadius = "4px";
        closeBtn.style.transition = "background 0.2s";

        closeBtn.addEventListener("mouseenter", () => {
          closeBtn.style.background = "var(--bg-tertiary)";
        });
        closeBtn.addEventListener("mouseleave", () => {
          closeBtn.style.background = "none";
        });

        closeBtn.addEventListener("click", () => {
          sidebarLayoutMode = "sidebar";
          movePolarChartSection("sidebar");
        });

        headerDiv.appendChild(closeBtn);

        container.innerHTML = headerDiv.outerHTML + polarChartSection.innerHTML;
        sidebar.style.display = "none";
        sidebarToggleBtn.style.display = "flex";
        if (mainContent) mainContent.classList.add("sidebar-closed");
        console.log("[main.js] Sidebar moved to analysis container");
      }
      break;

    case "sidebar":
      // Return to original sidebar position
      const originalSidebar = document.getElementById("sidebar");
      if (originalSidebar) {
        // Restore original inline styles and remove CSS classes
        chartsContainer.classList.remove("charts-block-layout");
        if (analysisContainer &amp;&amp; analysisContainer.parentElement) {
          analysisContainer.remove();
        }
        polarChartSection.style.order = "auto";
        originalSidebar.appendChild(polarChartSection);
        detachedWindow.classList.remove("show");
        sidebar.style.display = "flex";
        sidebar.style.flexDirection = "column";
        sidebarToggleBtn.style.display = "none";
        if (mainContent) mainContent.classList.remove("sidebar-closed");
        console.log("[main.js] Sidebar returned to original sidebar position");
      }
      break;
  }
}

// Handle floating window button
if (floatingWindowBtn) {
  floatingWindowBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebarLayoutMode = "floating";
    movePolarChartSection("floating");
    updateLayoutButtonVisibility();
  });

  floatingWindowBtn.addEventListener("mouseenter", () => {
    floatingWindowBtn.style.background = "var(--bg-secondary)";
    floatingWindowBtn.style.opacity = "0.8";
  });
  floatingWindowBtn.addEventListener("mouseleave", () => {
    floatingWindowBtn.style.background = "var(--bg-tertiary)";
    floatingWindowBtn.style.opacity = "1";
  });
}

// Handle below chart button
if (belowChartBtn) {
  belowChartBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebarLayoutMode = "charts-below";
    movePolarChartSection("charts-below");
    updateLayoutButtonVisibility();
  });

  belowChartBtn.addEventListener("mouseenter", () => {
    belowChartBtn.style.background = "var(--bg-secondary)";
    belowChartBtn.style.opacity = "0.8";
  });
  belowChartBtn.addEventListener("mouseleave", () => {
    belowChartBtn.style.background = "var(--bg-tertiary)";
    belowChartBtn.style.opacity = "1";
  });
}

// Handle return to sidebar button
if (returnSidebarBtn) {
  returnSidebarBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebarLayoutMode = "sidebar";
    movePolarChartSection("sidebar");
    updateLayoutButtonVisibility();
  });

  returnSidebarBtn.addEventListener("mouseenter", () => {
    returnSidebarBtn.style.background = "var(--bg-secondary)";
    returnSidebarBtn.style.opacity = "0.8";
  });
  returnSidebarBtn.addEventListener("mouseleave", () => {
    returnSidebarBtn.style.background = "var(--bg-tertiary)";
    returnSidebarBtn.style.opacity = "1";
  });
}

// Handle return to sidebar button from below chart mode
if (returnSidebarFromBelowBtn) {
  returnSidebarFromBelowBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebarLayoutMode = "sidebar";
    movePolarChartSection("sidebar");
    updateLayoutButtonVisibility();
  });

  returnSidebarFromBelowBtn.addEventListener("mouseenter", () => {
    returnSidebarFromBelowBtn.style.background = "var(--bg-secondary)";
    returnSidebarFromBelowBtn.style.opacity = "0.8";
  });
  returnSidebarFromBelowBtn.addEventListener("mouseleave", () => {
    returnSidebarFromBelowBtn.style.background = "var(--bg-tertiary)";
    returnSidebarFromBelowBtn.style.opacity = "1";
  });
}

// Helper function to update button visibility based on layout mode
function updateLayoutButtonVisibility() {
  if (
    floatingWindowBtn &amp;&amp;
    belowChartBtn &amp;&amp;
    returnSidebarBtn &amp;&amp;
    returnSidebarFromBelowBtn
  ) {
    if (sidebarLayoutMode === "floating") {
      // Show return button in sidebar header when in floating mode
      returnSidebarBtn.style.display = "block";
      floatingWindowBtn.style.display = "none";
      belowChartBtn.style.display = "none";
      // Hide below button
      returnSidebarFromBelowBtn.style.display = "none";
    } else if (sidebarLayoutMode === "charts-below") {
      // Hide buttons in sidebar header and show return button in polar chart header
      returnSidebarBtn.style.display = "none";
      floatingWindowBtn.style.display = "none";
      belowChartBtn.style.display = "none";
      // Show return button in the below chart section
      returnSidebarFromBelowBtn.style.display = "block";
    } else {
      // Show mode buttons when in sidebar
      floatingWindowBtn.style.display = "block";
      belowChartBtn.style.display = "block";
      returnSidebarBtn.style.display = "none";
      returnSidebarFromBelowBtn.style.display = "none";
    }
  }
}

// Handle close sidebar
if (closeSidebarBtn) {
  closeSidebarBtn.addEventListener("click", () => {
    sidebar.style.display = "none";
    sidebarToggleBtn.style.display = "flex";
    sidebarToggleBtn.style.alignItems = "center";
    sidebarToggleBtn.style.justifyContent = "center";
    if (mainContent) {
      mainContent.classList.add("sidebar-closed");
    }
    // Reset layout mode when closing sidebar
    sidebarLayoutMode = "sidebar";
    console.log("[main.js] Sidebar closed, main content expanded");
  });

  closeSidebarBtn.addEventListener("mouseenter", () => {
    closeSidebarBtn.style.opacity = "0.7";
  });
  closeSidebarBtn.addEventListener("mouseleave", () => {
    closeSidebarBtn.style.opacity = "1";
  });
}

// Handle sidebar toggle button
if (sidebarToggleBtn) {
  sidebarToggleBtn.addEventListener("click", () => {
    // Only open sidebar if currently in sidebar mode
    // If in floating or below mode, clicking toggle should close that mode instead
    if (sidebarLayoutMode === "floating") {
      // Close floating window and return to sidebar
      detachedWindow.classList.remove("show");
      sidebarLayoutMode = "sidebar";
      movePolarChartSection("sidebar");
      updateLayoutButtonVisibility();
      console.log("[main.js] Floating window closed via toggle button");
    } else if (sidebarLayoutMode === "charts-below") {
      // Close below mode and return to sidebar
      sidebarLayoutMode = "sidebar";
      movePolarChartSection("sidebar");
      updateLayoutButtonVisibility();
      console.log("[main.js] Below chart mode closed via toggle button");
    } else {
      // In sidebar mode - this shouldn't happen as toggle is hidden, but for safety
      sidebar.style.display = "flex";
      sidebar.style.flexDirection = "column";
      sidebarToggleBtn.style.display = "none";
      if (mainContent) {
        mainContent.classList.remove("sidebar-closed");
      }
      console.log("[main.js] Sidebar opened via toggle button");
    }
  });

  sidebarToggleBtn.addEventListener("mouseenter", () => {
    sidebarToggleBtn.style.backgroundColor = "var(--bg-tertiary)";
  });
  sidebarToggleBtn.addEventListener("mouseleave", () => {
    sidebarToggleBtn.style.backgroundColor = "var(--bg-secondary)";
  });
}

// Handle attach floating window back to sidebar
if (attachWindowBtn) {
  attachWindowBtn.addEventListener("click", () => {
    // Re-attach content to sidebar
    const polarChartSection = document.querySelector(".polar-chart-section");
    if (polarChartSection) {
      polarChartSection.innerHTML = detachedWindowContent.innerHTML;
    }
    detachedWindow.classList.remove("show");
    sidebar.style.display = "flex";
    sidebar.style.flexDirection = "column";
    sidebarToggleBtn.style.display = "none";
    if (mainContent) {
      mainContent.classList.remove("sidebar-closed");
    }
    sidebarLayoutMode = "sidebar";
    console.log("[main.js] Floating window attached back to sidebar");
  });
}

// Handle close floating window
if (closeWindowBtn) {
  closeWindowBtn.addEventListener("click", () => {
    detachedWindow.classList.remove("show");
    console.log("[main.js] Floating window closed");
  });
}

// Handle dragging for floating window
if (windowTitleBar) {
  windowTitleBar.addEventListener("mousedown", (e) => {
    isDragging = true;
    const rect = detachedWindow.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    detachedWindow.style.cursor = "grabbing";
  });

  document.addEventListener("mousemove", (e) => {
    if (isDragging) {
      const newX = e.clientX - dragOffsetX;
      const newY = e.clientY - dragOffsetY;

      // Constrain to viewport
      const constrainedX = Math.max(
        0,
        Math.min(newX, window.innerWidth - detachedWindow.offsetWidth)
      );
      const constrainedY = Math.max(
        0,
        Math.min(newY, window.innerHeight - detachedWindow.offsetHeight)
      );

      detachedWindow.style.left = constrainedX + "px";
      detachedWindow.style.top = constrainedY + "px";
      detachedWindow.style.right = "auto";
    }
  });

  document.addEventListener("mouseup", () => {
    if (isDragging) {
      isDragging = false;
      detachedWindow.style.cursor = "move";
    }
  });
}

document.addEventListener("keydown", (e) => {
  handleVerticalLineShortcuts(
    e,
    charts,
    verticalLinesX,
    fixedResultsEl,
    TIME_UNIT,
    calculateDeltas
  ).catch((err) =>
    console.error("[main.js] Error in handleVerticalLineShortcuts:", err)
  );
});

// === Theme Toggle ===
initTheme();
const themeToggleBtn = document.getElementById("themeToggleBtn");
const themeIcon = document.getElementById("themeIcon");
const themeName = document.getElementById("themeName");

if (themeToggleBtn) {
  themeToggleBtn.addEventListener("click", () => {
    const newTheme = toggleTheme();
    updateThemeButton(newTheme);
    console.log(`[main.js] Theme switched to: ${newTheme}`);

    // Update all chart colors with the new theme
    updateAllChartAxisColors(charts);
  });
}

function updateThemeButton(theme) {
  if (themeIcon &amp;&amp; themeName) {
    if (theme === "light") {
      themeIcon.textContent = "ðŸŒ™";
      themeName.textContent = "Dark";
    } else {
      themeIcon.textContent = "â˜€ï¸";
      themeName.textContent = "Light";
    }
  }
}

// Update button on load
updateThemeButton(getCurrentTheme());

// Listen for theme changes from other sources
window.addEventListener("themeChanged", (e) => {
  updateThemeButton(e.detail.theme);
  console.log("[main.js] Theme changed event received:", e.detail.theme);
});

// Reference existing buttons from header
const showChannelListBtn = document.getElementById("showChannelListBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");

// Keep buttons enabled/disabled based on stack sizes
function updateUndoRedoButtons() {
  try {
    const canUndo = !!(
      channelState.getHistory &amp;&amp; channelState.getHistory().length > 0
    );
    const canRedo = !!(
      channelState.getRedoStack &amp;&amp; channelState.getRedoStack().length > 0
    );
    undoBtn.disabled = !canUndo;
    redoBtn.disabled = !canRedo;
  } catch (e) {
    undoBtn.disabled = true;
    redoBtn.disabled = true;
  }
}

undoBtn.addEventListener("click", () => {
  try {
    channelState.undoLast();
  } finally {
    updateUndoRedoButtons();
  }
});
redoBtn.addEventListener("click", () => {
  try {
    channelState.redoLast &amp;&amp; channelState.redoLast();
  } finally {
    updateUndoRedoButtons();
  }
});

// Export Computed Channel button
const exportComputedChannelBtn = document.getElementById(
  "exportComputedChannelBtn"
);
exportComputedChannelBtn.addEventListener("click", () => {
  try {
    // Export ALL computed channels as CFG+DAT (COMTRADE 2013 format)
    if (!data || !data.computedData || data.computedData.length === 0) {
      alert(
        "âŒ No computed channels to export. Please create and execute equations first from the Channel List popup."
      );
      return;
    }

    const sampleRate = cfg?.sampleRate || 4800;
    exportAllComputedChannels(data, sampleRate);
  } catch (error) {
    console.error("[Export] Error:", error);
    alert(`âŒ Export failed: ${error.message}`);
  }
});

// CSV Export button
const exportCSVBtn = document.getElementById("exportCSVBtn");
exportCSVBtn.addEventListener("click", () => {
  try {
    if (!data || !data.computedData || data.computedData.length === 0) {
      alert(
        "âŒ No computed channels to export. Please create and execute equations first from the Channel List popup."
      );
      return;
    }

    // Generate filename with timestamp
    const now = new Date();
    const timestamp = now.toISOString().slice(0, 19).replace(/[:-]/g, "");
    const filename = `computed-channels-${timestamp}.csv`;
    exportComputedChannelsAsCSV(data, filename);
  } catch (error) {
    console.error("[CSV Export] Error:", error);
    alert(`âŒ CSV export failed: ${error.message}`);
  }
});

// Update when state changes
channelState.subscribe(() => updateUndoRedoButtons());
// Initialize
updateUndoRedoButtons();

// Show Channel List button event listener
showChannelListBtn.addEventListener("click", () => {
  try {
    // Open popup window with Tabulator
    showChannelListWindow(
      channelState,
      (type, fromIdx, toIdx) => {
        // Channel reordering callback
      },
      (type, idx, color) => {
        if (type === "analog") {
          channelState.analog.lineColors[idx] = color;
        } else if (type === "digital") {
          channelState.digital.lineColors[idx] = color;
        }
      },
      charts,
      cfg,
      data
    );
  } catch (error) {
    console.error("Error opening channel list:", error);
  }
});

// Close modal when X is clicked
document
  .getElementById("close-channel-modal")
  ?.addEventListener("click", () => {
    const modal = document.getElementById("channel-list-modal");
    if (modal) modal.style.display = "none";
  });

// Close modal when clicking outside
document
  .getElementById("channel-list-modal")
  ?.addEventListener("click", (e) => {
    if (e.target.id === "channel-list-modal") {
      e.target.style.display = "none";
    }
  });

// --- Main Handlers ---
async function handleLoadFiles() {
  console.log(
    "[handleLoadFiles] Button clicked, files selected:",
    cfgFileInput.files.length
  );

  if (cfgFileInput.files.length === 0) {
    // Debug: No files selected
    showError("Please select at least one CFG/DAT file pair.", fixedResultsEl);
    return;
  }

  try {
    // Show loading indicator
    fixedResultsEl.innerHTML =
      '&lt;div style="padding: 20px; text-align: center; color: var(--text-secondary);">&lt;p>ðŸ”„ Loading and parsing files...&lt;/p>&lt;p style="font-size: 0.9rem; margin-top: 10px;">Please wait, processing ' +
      cfgFileInput.files.length +
      " file(s)&lt;/p>&lt;/div>";

    console.log("[handleLoadFiles] ðŸ“‚ PHASE 1: Parsing files in batch mode");

    // PHASE 1: Parse and merge files WITHOUT rendering anything
    // This prevents multiple chart recreation cycles
    const result = await processFilesInBatches(
      cfgFileInput.files,
      TIME_UNIT,
      (progress) => {
        // Debug: Progress tracking disabled
      }
    );

    if (result.error) {
      showError(`File processing failed: ${result.error}`, fixedResultsEl);
      return;
    }

    // Assign to global variables
    cfg = result.cfg;
    data = result.data;

    // Merge information - debug logs disabled
    if (!data.time || data.time.length === 0) {
      showError("Failed to parse COMTRADE data.", fixedResultsEl);
      return;
    }

    console.log("[handleLoadFiles] ðŸ“Š PHASE 2: Initializing data state");

    // PHASE 2: Update global data state (light operations)
    dataState.analog = data.analogData;
    dataState.digital = data.digitalData;

    // Update UI with filenames
    const filenameText = result.isMerged
      ? `Merged: ${result.filenames.join(", ")}`
      : `Loaded: ${result.filenames[0]}`;

    cfgFileNameEl.textContent = filenameText;
    datFileNameEl.textContent = result.isMerged
      ? `(${result.fileCount} DAT files)`
      : `DAT File: ${result.filenames[0]}.dat`;

    const groups = autoGroupChannels(cfg.analogChannels);

    // ===== UI HELPER CALLS (Light) =====
    showFileInfo();
    updateFileInfo(
      result.filenames[0],
      result.isMerged
        ? `${result.fileCount} files`
        : `${result.filenames[0]}.dat`
    );
    updateStatsCards({
      sampleRate: cfg.sampleRate || 4800,
      duration: cfg.duration || 2000,
      analogChannels: cfg.analogChannels,
      digitalChannels: cfg.digitalChannels,
    });
    toggleChartsVisibility(true);

    console.log("[handleLoadFiles] ðŸŽ¨ PHASE 3: Channel state initialization");

    // PHASE 3: Initialize channel state (this is heavy - suspend history)
    if (channelState &amp;&amp; channelState.suspendHistory)
      channelState.suspendHistory();
    try {
      initializeChannelState(cfg, data);

      // NEW: Populate group IDs from autoGroupChannels results
      // Convert group objects { groupId, indices, ... } into per-channel array
      // Build array where each index corresponds to a channel and contains its group ID
      const analogGroupIds = new Array(cfg.analogChannels.length);
      groups.forEach((group) => {
        group.indices.forEach((channelIdx) => {
          analogGroupIds[channelIdx] = group.groupId; // e.g., "G0", "G1", "G2"
        });
      });
      channelState.analog.groups = analogGroupIds;
      console.log(
        "[handleLoadFiles] âœ… Populated analog group IDs:",
        analogGroupIds
      );
    } finally {
      if (channelState &amp;&amp; channelState.resumeHistory)
        channelState.resumeHistory();
    }

    // Yield to event loop to let browser process other tasks
    await yieldToEventLoop(50);

    console.log("[handleLoadFiles] ðŸ“ˆ PHASE 4: Chart rendering (single batch)");

    // PHASE 4: Render all charts in ONE cycle (not multiple times)
    renderComtradeCharts(
      cfg,
      data,
      chartsContainer,
      charts,
      verticalLinesX,
      createState,
      calculateDeltas,
      TIME_UNIT,
      channelState
    );

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log(
      "[handleLoadFiles] ðŸŽ¯ PHASE 5: Polar chart initialization (deferred)"
    );

    // PHASE 5: Initialize Polar Chart WITH DEFERRED RENDERING
    // âœ… Strategy: Create instance immediately, but defer SVG rendering to next idle frame
    // This unblocks the UI thread so user can interact with charts immediately
    try {
      console.log("[handleLoadFiles] Creating PolarChart instance...");
      polarChart = new PolarChart("polarChartContainer");
      polarChart.init(); // This just clears container

      // â±ï¸ Defer the expensive updatePhasorAtTimeIndex to avoid blocking
      // Use requestIdleCallback for low-priority background task
      if (window.requestIdleCallback) {
        window.requestIdleCallback(
          () => {
            try {
              console.log("[PolarChart] Background: Updating phasor data...");
              polarChart.updatePhasorAtTimeIndex(cfg, data, 0);
              console.log("[PolarChart] âœ… Background phasor update complete");
            } catch (err) {
              console.error("[PolarChart] Background update failed:", err);
            }
          },
          { timeout: 2000 } // Timeout after 2s if browser too busy
        );
      } else {
        // Fallback: Use requestAnimationFrame for older browsers
        requestAnimationFrame(() => {
          setTimeout(() => {
            try {
              console.log("[PolarChart] Fallback: Updating phasor data...");
              polarChart.updatePhasorAtTimeIndex(cfg, data, 0);
              console.log("[PolarChart] âœ… Fallback phasor update complete");
            } catch (err) {
              console.error("[PolarChart] Fallback update failed:", err);
            }
          }, 100);
        });
      }

      console.log(
        "[handleLoadFiles] âœ… Polar chart instance created (rendering deferred)"
      );
    } catch (err) {
      console.error(
        "[handleLoadFiles] âŒ Failed to initialize polar chart:",
        err.message
      );
    }

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[handleLoadFiles] ðŸ“Ÿ PHASE 6: Computed channels");

    // PHASE 6: Load persisted computed channels
    const savedChannels = loadComputedChannelsFromStorage();
    if (savedChannels.length > 0) {
      if (!data.computedData) data.computedData = [];
      for (const savedChannel of savedChannels) {
        const exists = data.computedData.some(
          (ch) => ch.equation === savedChannel.expression
        );
        if (!exists) {
          data.computedData.push({
            id: savedChannel.name,
            equation: savedChannel.expression,
            data: savedChannel.data,
            index: data.computedData.length,
          });
        }
      }
      if (data.computedData.length > 0) {
        const exportBtn = document.getElementById("exportComputedChannelBtn");
        const csvBtn = document.getElementById("exportCSVBtn");
        if (exportBtn) exportBtn.disabled = false;
        if (csvBtn) csvBtn.disabled = false;
        renderComputedChannels(
          data,
          chartsContainer,
          charts,
          verticalLinesX,
          channelState
        );
      }
    }
    setupComputedChannelsListener();

    // Yield to event loop
    await yieldToEventLoop(50);

    console.log("[handleLoadFiles] ðŸ”— PHASE 7: Chart integrations");

    // PHASE 7: Setup polar chart with vertical lines
    if (polarChart) {
      try {
        setupPolarChartWithVerticalLines(
          polarChart,
          cfg,
          data,
          verticalLinesX,
          charts
        );
        console.log("[handleLoadFiles] âœ… Polar chart integrated");
      } catch (err) {
        console.error(
          "[handleLoadFiles] âŒ Polar chart integration failed:",
          err.message
        );
      }
    }

    // PHASE 8: Final setup
    try {
      applyInitialStartDurations(channelState, dataState, charts);
    } catch (e) {
      console.debug("applyInitialStartDurations failed:", e);
    }

    try {
      const maxDuration = data.time ? data.time[data.time.length - 1] : 1;
      verticalLineControl = initVerticalLineControl({
        dataState: dataState,
        maxDuration: maxDuration,
        onPositionChange: (value) => {
          // Vertical line position changed
        },
      });
    } catch (error) {
      console.error(
        "[handleLoadFiles] Failed to initialize vertical line control:",
        error
      );
    }

    if (window._resizableGroup) window._resizableGroup.disconnect();
    window._resizableGroup = new ResizableGroup(".dragBar");

    // âš¡ Initialize fast lookup map for channel lookups (O(1) instead of O(n))
    rebuildChannelIDMap();

    // âš¡ Rebuild map whenever channelIDs change (e.g., file load, reorder)
    try {
      channelState.analog?.subscribe?.(() => {
        rebuildChannelIDMap();
      });
      channelState.digital?.subscribe?.(() => {
        rebuildChannelIDMap();
      });
    } catch (e) {
      console.warn("[main] Failed to set up channelID map rebuild:", e);
    }

    // â±ï¸ OPTIMIZATION: Defer subscription setup to avoid blocking UI
    // subscribeChartUpdates sets up many listeners - do this in idle time
    if (window.requestIdleCallback) {
      window.requestIdleCallback(
        () => {
          console.log(
            "[handleLoadFiles] Background: Setting up chart subscriptions..."
          );
          subscribeChartUpdates(
            channelState,
            dataState,
            charts,
            chartsContainer,
            verticalLinesX,
            cfg,
            data,
            createState,
            calculateDeltas,
            TIME_UNIT
          );
          console.log("[handleLoadFiles] âœ… Chart subscriptions ready");
        },
        { timeout: 2000 }
      );
    } else {
      // Fallback for older browsers
      setTimeout(() => {
        subscribeChartUpdates(
          channelState,
          dataState,
          charts,
          chartsContainer,
          verticalLinesX,
          cfg,
          data,
          createState,
          calculateDeltas,
          TIME_UNIT
        );
      }, 500);
    }

    console.log(
      "[handleLoadFiles] ðŸŽ‰ COMPLETE - All files loaded and rendered successfully"
    );
    fixedResultsEl.innerHTML = "";
  } catch (error) {
    console.error("[handleLoadFiles] âŒ Error:", error.message);
    showError(
      "An error occurred while processing the COMTRADE files. Check the console for details.",
      fixedResultsEl
    );
  }
}
/**
 * Initialize channelState from parsed COMTRADE configuration
 *
 * @function initializeChannelState
 * @category Initialization
 * @since 1.0.0
 *
 * @description
 * Populates channelState with metadata from the parsed CFG file. Assigns
 * colors from palettes, generates stable channelIDs, and initializes all
 * per-channel arrays (scales, starts, durations, inverts) with default values.
 * History tracking is suspended during initialization to avoid recording
 * individual array mutations.
 *
 * @param {Object} cfg - Parsed COMTRADE configuration
 * @param {Array} cfg.analogChannels - Analog channel metadata
 * @param {Array} cfg.digitalChannels - Digital channel metadata
 * @param {Object} data - Parsed COMTRADE data (unused but kept for signature)
 *
 * @returns {void} Mutates channelState directly
 *
 * @mermaid
 * flowchart TD
 *     A["initializeChannelState entry"] --> B["Select palette row"]
 *     B --> C["Prepare analog arrays"]
 *     C1["Clear arrays"] -.-> C
 *     C2["Create channelIDs array"] -.-> C1
 *     C3["Seed axesScales with 1e-6"] -.-> C2
 *     C4["Loop over analog channels"] -.-> C3
 *     C5["Assign palette color"] -.-> C4
 *     C6["Push metadata into arrays"] -.-> C5
 *     C7["Generate stable channelID"] -.-> C6
 *     C8["Store channelID"] -.-> C7
 *     C9["Advance palette index"] -.-> C8
 *     C --> D["Set analog axes labels"]
 *     D --> E["Initialize digital arrays with same steps"]
 *     E --> F["channelState populated"]
 *     F --> G["All per-channel arrays aligned"]
 *     style A fill:#4CAF50,stroke:#1B5E20,color:#fff
 *     style C fill:#BBDEFB,stroke:#1565C0,color:#000
 *     style E fill:#BBDEFB,stroke:#1565C0,color:#000
 *     style F fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style G fill:#4CAF50,stroke:#1B5E20,color:#fff
 *
 * @example
 * // Initialize after parsing COMTRADE files
 * const cfg = parseCFG(cfgText, TIME_UNIT);
 * const data = parseDAT(datContent, cfg, fileType, TIME_UNIT);
 * initializeChannelState(cfg, data);
 * // Result: channelState populated with all channel metadata
 *
 * @algorithm
 * 1. Get palette row based on whiteBackground.value
 * 2. Ensure groups and yUnits arrays exist (empty arrays)
 * 3. Initialize analog channels:
 *    a. Clear all existing arrays (length = 0)
 *    b. Initialize channelIDs as empty array
 *    c. Add base axesScales value (1e-6)
 *    d. For each analog channel:
 *       - Assign color from palette (cycling through colors)
 *       - Set stroke = color
 *       - Push to yLabels, lineColors, yUnits arrays
 *       - Push default scale/start/duration/invert values
 *       - Generate stable channelID if missing
 *       - Push channelID to array
 *       - Increment palette index
 *    e. Set xLabel = "Time", xUnit = "sec"
 * 4. Initialize digital channels (same process as analog):
 *    a. Clear existing arrays
 *    b. Add axesScales values (1e-6, 1)
 *    c. Process each digital channel
 *    d. Set xLabel and xUnit
 *
 * @dependencies
 * - whiteBackground - State controlling palette selection
 * - analogPalette - Color palette array for analog channels
 * - digitalPalette - Color palette array for digital channels
 * - channelState - Reactive state object to populate
 *
 * @sideeffects
 * - Clears and repopulates channelState.analog arrays
 * - Clears and repopulates channelState.digital arrays
 * - Mutates cfg channel objects (adds color, stroke, channelID)
 * - Triggers reactive subscribers (if not suspended)
 *
 * @testcase
 * Input: cfg with 3 analog channels, 2 digital channels
 * Expected:
 * - channelState.analog arrays have length 3
 * - channelState.digital arrays have length 2
 * - All channels have unique channelIDs
 * - Colors assigned from palette
 *
 * @see {@link parseCFG} - Generates the cfg object
 * @see {@link handleLoadFiles} - Calls this function during file loading
 */
// --- Initialize channelState ---
function initializeChannelState(cfg, data) {
  const paletteRow = whiteBackground.value || 0;

  // ensure groups and yUnits exist as arrays to keep lengths consistent
  channelState.analog.groups = channelState.analog.groups || [];
  channelState.analog.yUnits = channelState.analog.yUnits || [];
  channelState.digital.groups = channelState.digital.groups || [];
  channelState.digital.yUnits = channelState.digital.yUnits || [];

  // Analog channels
  channelState.analog.yLabels.length = 0;
  channelState.analog.lineColors.length = 0;
  channelState.analog.yUnits.length = 0;
  channelState.analog.axesScales.length = 0;
  // stable ids for channels in this session
  channelState.analog.channelIDs = [];
  channelState.analog.axesScales.push(1e-6);
  let analogPaletteIdx = 0;
  cfg.analogChannels.forEach((ch, idx) => {
    ch.color =
      ch.color ||
      analogPalette[paletteRow][
        analogPaletteIdx % analogPalette[paletteRow].length
      ];
    ch.stroke = ch.color;
    channelState.analog.yLabels.push(ch.id);
    channelState.analog.lineColors.push(ch.color);
    channelState.analog.yUnits.push(ch.unit || "");
    channelState.analog.scales.push(ch.scale || 1);
    channelState.analog.starts.push(ch.start || 0);
    channelState.analog.durations.push(ch.duration || "");
    channelState.analog.inverts.push(ch.invert || false);
    // assign a stable channelID if missing
    if (!ch.channelID) {
      ch.channelID = `analog-${idx}-${Math.random().toString(36).slice(2, 9)}`;
    }
    channelState.analog.channelIDs.push(ch.channelID);
    analogPaletteIdx++;
  });
  channelState.analog.xLabel = "Time";
  channelState.analog.xUnit = "sec";

  // Digital channels
  channelState.digital.yLabels.length = 0;
  channelState.digital.lineColors.length = 0;
  channelState.digital.yUnits.length = 0;
  channelState.digital.axesScales.length = 0;
  channelState.digital.channelIDs = [];
  channelState.digital.axesScales.push(1e-6, 1);
  let digitalPaletteIdx = 0;
  cfg.digitalChannels.forEach((ch, idx) => {
    ch.color =
      ch.color ||
      digitalPalette[paletteRow][
        digitalPaletteIdx % digitalPalette[paletteRow].length
      ];
    ch.stroke = ch.color;
    channelState.digital.yLabels.push(ch.id);
    channelState.digital.lineColors.push(ch.color);
    channelState.digital.yUnits.push("");
    channelState.digital.scales.push(ch.scale || 1);
    channelState.digital.starts.push(ch.start || 0);
    channelState.digital.durations.push(ch.duration || "");
    channelState.digital.inverts.push(ch.invert || false);
    if (!ch.channelID) {
      ch.channelID = `digital-${idx}-${Math.random().toString(36).slice(2, 9)}`;
    }
    channelState.digital.channelIDs.push(ch.channelID);
    digitalPaletteIdx++;
  });
  channelState.digital.xLabel = "Time";
  channelState.digital.xUnit = "sec";
}

/**
 * Setup listener for computed channels being saved
 * Re-renders computed channels chart when new ones are created
 * OPTIMIZED: Uses debouncing and requestAnimationFrame for performance
 */
function setupComputedChannelsListener() {
  // âœ… OPTIMIZATION: Debounce rapid computed channel events (300ms delay)
  const handleComputedChannelSaved = debounce((event) => {
    console.log("[Main] Processing computed channel saved event");

    // âœ… Enable export buttons when computed channel is saved
    const exportBtn = document.getElementById("exportComputedChannelBtn");
    const csvBtn = document.getElementById("exportCSVBtn");
    if (exportBtn) {
      exportBtn.disabled = false;
    }
    if (csvBtn) {
      csvBtn.disabled = false;
    }

    if (!data || !data.time) {
      console.error("[Main] Data not available for computed channel rendering");
      return;
    }

    // Process event data
    if (event.detail.fullData) {
      if (!data.computedData) data.computedData = [];

      // Check if it already exists
      const exists = data.computedData.some(
        (ch) => ch.id === event.detail.fullData.id
      );
      if (!exists) {
        const computedChannelObj = event.detail.fullData;

        // âœ… Validate data array contains NUMBERS
        if (computedChannelObj.data &amp;&amp; Array.isArray(computedChannelObj.data)) {
          computedChannelObj.data = computedChannelObj.data.map((val) => {
            const num = Number(val);
            return isNaN(num) ? 0 : num;
          });
        }

        data.computedData.push(computedChannelObj);

        // Store in globalData as well
        if (window.globalData &amp;&amp; !window.globalData.computedData) {
          window.globalData.computedData = [];
        }
        if (window.globalData &amp;&amp; window.globalData.computedData) {
          window.globalData.computedData.push(computedChannelObj);
        }

        // Save to localStorage for persistence
        saveComputedChannelsToStorage(data.computedData);
      }
    }

    // âœ… OPTIMIZATION: Use requestAnimationFrame to defer chart rendering
    // This prevents blocking user interactions while charts are being created
    requestAnimationFrame(() => {
      const chartsContainer = document.getElementById("charts");
      if (!chartsContainer) {
        console.error("[Main] Charts container not found");
        return;
      }

      // Check if computed chart already exists
      const existingComputedChartDiv = chartsContainer.querySelector(
        '[data-chart-type="computed"]'
      );

      if (existingComputedChartDiv) {
        existingComputedChartDiv.remove();

        // Remove from charts array
        const chartIndex = charts.findIndex((c) => c &amp;&amp; c._type === "computed");
        if (chartIndex >= 0) {
          charts.splice(chartIndex, 1);
        }
      }

      // Create/recreate the computed chart with all current computed channels
      try {
        console.log(
          "[Main] Rendering computed channels...",
          data.computedData?.length || 0
        );
        renderComputedChannels(
          data,
          chartsContainer,
          charts,
          verticalLinesX,
          channelState
        );

        // Scroll to the new chart
        const newComputedChart = chartsContainer.querySelector(
          '[data-chart-type="computed"]'
        );
        if (newComputedChart) {
          newComputedChart.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
          });
        }
      } catch (error) {
        console.error("[Main] Error rendering computed channels:", error);
      }
    });
  }, 300); // 300ms debounce delay

  window.addEventListener("computedChannelSaved", handleComputedChannelSaved);
}

// One-time helper: apply initial start/duration windows after charts are created
function applyInitialStartDurations(channelState, dataState, charts) {
  const types = ["analog", "digital"];
  types.forEach((type, typeIdx) => {
    const chart = charts[typeIdx];
    if (
      !chart ||
      !Array.isArray(dataState[type]) ||
      !Array.isArray(dataState[type][0])
    )
      return;
    const timeArr = dataState[type][0];
    if (!timeArr || timeArr.length === 0) return;
    const first = timeArr[0];
    const last = timeArr[timeArr.length - 1];
    const totalSamples = timeArr.length;
    const starts = channelState[type].starts || [];
    const durations = channelState[type].durations || [];

    for (let i = 0; i &lt; Math.max(starts.length, durations.length); i++) {
      let sRaw = starts[i];
      let dRaw = durations[i];
      let sNum = sRaw == null ? NaN : Number(sRaw);
      let dNum = dRaw == null ? NaN : Number(dRaw);

      if (Number.isInteger(sNum) &amp;&amp; sNum >= 0 &amp;&amp; sNum &lt; totalSamples) {
        sNum = timeArr[sNum];
      }
      if (Number.isInteger(dNum) &amp;&amp; dNum > 0 &amp;&amp; dNum &lt; totalSamples) {
        const dt = (last - first) / Math.max(1, totalSamples - 1);
        dNum = dNum * dt;
      }
      if (Number.isFinite(sNum)) {
        if (sNum &lt; first) sNum = first;
        if (sNum > last) sNum = last;
      }
      if (Number.isFinite(dNum) &amp;&amp; Number.isFinite(sNum)) {
        if (sNum + dNum > last) dNum = Math.max(0, last - sNum);
      }

      try {
        if (Number.isFinite(sNum) &amp;&amp; Number.isFinite(dNum)) {
          if (typeof chart.batch === "function") {
            chart.batch(() =>
              chart.setScale("x", { min: sNum, max: sNum + dNum })
            );
          } else {
            chart.setScale("x", { min: sNum, max: sNum + dNum });
          }
          break; // apply first valid window only
        } else if (Number.isFinite(sNum)) {
          chart.setScale("x", { min: sNum, max: null });
          break;
        }
      } catch (e) {
        // ignore and try next channel
      }
    }
  });
}

// âš¡ OPTIMIZATION NOTE: Removed old updateChartsSafely function
// Color updates are now handled efficiently by the chartManager.js color subscriber
// which performs in-place updates without full chart recreation

// âš¡ OPTIMIZATION: Color updates are handled by the chartManager color subscriber
// which does efficient in-place updates. Disable the old updateChartsSafely to avoid
// full renders on color changes.
// OLD CODE (disabled): channelState.subscribe for lineColors â†’ updateChartsSafely
// NEW PATH: lineColors change â†’ chartManager color subscriber â†’ in-place chart update

// Debug: watch start/duration state changes and log via debugPanelLite so we can trace
try {
  channelState.subscribeProperty(
    "start",
    (change) => {
      try {
        debugLite.log("state.start.change", change);
      } catch (e) {}
    },
    { descendants: true }
  );
  channelState.subscribeProperty(
    "duration",
    (change) => {
      try {
        debugLite.log("state.duration.change", change);
      } catch (e) {}
    },
    { descendants: true }
  );
} catch (e) {
  /* subscribeProperty not available - skip */
}

// Parent message handler: accept callbacks posted from the child popup
/**
 * Message Event Handler - Routes child window messages to appropriate handlers
 *
 * @description
 * Handles window.postMessage events from the child popup window (ChannelList/Tabulator).
 * Routes different message types to appropriate update functions, maintaining synchronization
 * between the child UI and parent application state. Supports multiple payload formats
 * for backwards compatibility.
 *
 * @mermaid
 * flowchart TD
 *     A["window message event"] --> B{"Source is ChildWindow?"}
 *     B -->|No| C["Ignore message"]
 *     B -->|Yes| D["Read type and payload"]
 *     D --> E{"Dispatch by type"}
 *     E -->|callback_color| E1["Update color via ID"]
 *     E -->|callback_scale| E2["Update scale via ID"]
 *     E -->|callback_start| E3["Update start via ID"]
 *     E -->|callback_duration| E4["Update duration via ID"]
 *     E -->|callback_invert| E5["Update invert via ID"]
 *     E -->|callback_channelName| E6["Update label via ID"]
 *     E -->|callback_group| E7["Write group field"]
 *     E -->|callback_addChannel| E8["Insert new channel"]
 *     E -->|callback_delete| E9["Delete channel"]
 *     E -->|callback_update| E10["Legacy routing"]
 *     E -->|other| E11["Log unknown type"]
 *     E1 --> F["channelState updated"]
 *     E2 --> F
 *     E3 --> F
 *     E4 --> F
 *     E5 --> F
 *     E6 --> F
 *     E7 --> F
 *     E8 --> F
 *     E9 --> F
 *     E10 --> F
 *     E11 --> G["Log error and continue"]
 *     F --> H["Notify subscribers"]
 *     H --> I["Charts refresh"]
 *     I --> J["UI reflects change"]
 *     style A fill:#E3F2FD,stroke:#1565C0,color:#000
 *     style F fill:#F3E5F5,stroke:#6A1B9A,color:#fff
 *     style J fill:#C8E6C9,stroke:#2E7D32,color:#000
 *     style E11 fill:#FFCDD2,stroke:#C62828,color:#000
 */
window.addEventListener("message", (ev) => {
  const msgStartTime = performance.now();
  const msg = ev &amp;&amp; ev.data;
  if (!msg || msg.source !== "ChildWindow") return;
  const { type, payload } = msg;

  // â±ï¸ DIAGNOSTIC: Track all phases of message processing
  const timings = {
    start: msgStartTime,
    parsed: 0,
    switched: 0,
    subscribers: 0,
    chartUpdate: 0,
    total: 0,
  };

  console.log(`[Performance] ðŸ“¨ Message received from ChildWindow: ${type}`, {
    timestamp: msgStartTime.toFixed(2),
  });

  try {
    debugLite.log("child->parent", {
      type,
      channelID: payload?.channelID,
      field: payload?.field || payload?.name || payload?.newName || null,
      rowId: payload?.row?.id ?? payload?.rowId ?? null,
    });
  } catch (e) {}
  try {
    switch (type) {
      // Backwards-compat: ChannelList historically sent generic 'callback_update' messages
      // for many editable fields. If we receive that, inspect payload.field and route to
      // the dedicated handlers (e.g., group) so parent updates channelState correctly.
      case CALLBACK_TYPE.INVERT: {
        const { channelID, newValue, row } = payload || {};
        if (channelID) {
          updateChannelFieldByID(channelID, "inverts", !!newValue);
        } else if (row) {
          const t = (row.type || "").toLowerCase();
          const idx = Number(row.originalIndex ?? row.id - 1);
          updateChannelFieldByIndex(t, idx, "inverts", !!row.invert);
        }
        break;
      }
      case "callback_update": {
        try {
          const f =
            payload &amp;&amp; payload.field
              ? String(payload.field).toLowerCase()
              : null;
          if (f === "group") {
            // reuse GROUP handling logic by falling through to the GROUP case
            // construct a synthetic message and assign type for processing below
            // (we'll handle inline here to avoid code duplication)
            let row = payload &amp;&amp; payload.row ? payload.row : null;
            let channelID = null;
            const newGroup =
              payload &amp;&amp; payload.newValue !== undefined
                ? payload.newValue
                : payload &amp;&amp; payload.group !== undefined
                ? payload.group
                : null;
            if (!row) {
              if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
                channelID = payload[1];
              else if (payload &amp;&amp; payload.channelID)
                channelID = payload.channelID;
            }
            if (channelID) {
              const found = findChannelByID(channelID);
              if (found) {
                channelState[found.type].groups =
                  channelState[found.type].groups || [];
                channelState[found.type].groups[found.idx] = newGroup;
                break;
              }
            }
            if (!row) break;
            const t = (row.type || "").toLowerCase();
            // prefer explicit originalIndex/idx, else fall back to numeric id (1-based) when present
            let oi = Number(row.originalIndex ?? row.idx ?? -1);
            if (!Number.isFinite(oi) || oi &lt; 0) {
              const maybeId = Number(row.id ?? row.name);
              if (Number.isFinite(maybeId)) oi = maybeId - 1;
            }
            if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
              channelState[t].groups = channelState[t].groups || [];
              channelState[t].groups[oi] = newGroup;
              try {
                debugLite.log("msg.group.byIndex", {
                  type: t,
                  idx: oi,
                  newGroup,
                });
              } catch (e) {}
            } else {
              let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
              if (idx >= 0) {
                channelState.analog.groups = channelState.analog.groups || [];
                channelState.analog.groups[idx] = newGroup;
                try {
                  debugLite.log("msg.group.byLabel", {
                    type: "analog",
                    idx,
                    newGroup,
                  });
                } catch (e) {}
              } else {
                idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
                if (idx >= 0) {
                  channelState.digital.groups =
                    channelState.digital.groups || [];
                  channelState.digital.groups[idx] = newGroup;
                  try {
                    debugLite.log("msg.group.byLabel", {
                      type: "digital",
                      idx,
                      newGroup,
                    });
                  } catch (e) {}
                } else {
                  try {
                    debugLite.log("msg.group.notfound", { row, payload });
                  } catch (e) {}
                }
              }
            }
          }
        } catch (e) {
          /* ignore */
        }
        break;
      }
      case CALLBACK_TYPE.COLOR: {
        // Support payload shapes:
        // - legacy: { row: {...}, newValue: ... }
        // - tabulator: payload = [chartInstance, channelID, newValue]
        // - alt: { channelID, newValue }
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        let color =
          payload &amp;&amp; payload.newValue
            ? payload.newValue
            : payload &amp;&amp; payload.color
            ? payload.color
            : null;
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3) {
            channelID = payload[1];
            color = payload[2];
          } else if (payload &amp;&amp; payload.channelID) {
            channelID = payload.channelID;
          }
        }

        if (channelID) {
          const updated = updateChannelFieldByID(
            channelID,
            "lineColors",
            color
          );
          if (updated) return;
          // fall through to legacy behavior if update failed
        }

        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          // use helper with bounds checks
          updateChannelFieldByIndex(t, oi, "lineColors", color);
        } else {
          // fallback: match by label
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0)
            updateChannelFieldByIndex("analog", idx, "lineColors", color);
          else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0)
              updateChannelFieldByIndex("digital", idx, "lineColors", color);
          }
        }
        break;
      }
      case CALLBACK_TYPE.SCALE: {
        // support channelID-based payloads: [chartInstance, channelID, newVal] or {channelID, newValue}
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newVal =
          payload &amp;&amp; payload.newValue !== undefined
            ? payload.newValue
            : payload &amp;&amp; payload.scale !== undefined
            ? payload.scale
            : null;
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          const updated = updateChannelFieldByID(channelID, "scales", newVal);
          if (updated) return;
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          updateChannelFieldByIndex(t, oi, "scales", newVal);
        } else {
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0)
            updateChannelFieldByIndex("analog", idx, "scales", newVal);
          else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0)
              updateChannelFieldByIndex("digital", idx, "scales", newVal);
          }
        }
        break;
      }
      case CALLBACK_TYPE.START: {
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newVal =
          payload &amp;&amp; payload.newValue !== undefined
            ? payload.newValue
            : payload &amp;&amp; payload.start !== undefined
            ? payload.start
            : null;
        try {
          debugLite.log("msg.start.received", { payload, row, newVal });
        } catch (e) {}
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          const updated = updateChannelFieldByID(channelID, "starts", newVal);
          if (updated) return;
          try {
            debugLite.log("msg.start.byChannelID", {
              channelID,
              newVal,
              updated,
            });
          } catch (e) {}
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          updateChannelFieldByIndex(t, oi, "starts", newVal);
          try {
            debugLite.log("msg.start.byIndex", { type: t, oi, newVal, ok });
          } catch (e) {}
        } else {
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0)
            updateChannelFieldByIndex("analog", idx, "starts", newVal);
          else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0)
              updateChannelFieldByIndex("digital", idx, "starts", newVal);
          }
        }
        break;
      }
      case CALLBACK_TYPE.DURATION: {
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newVal =
          payload &amp;&amp; payload.newValue !== undefined
            ? payload.newValue
            : payload &amp;&amp; payload.duration !== undefined
            ? payload.duration
            : null;
        try {
          debugLite.log("msg.duration.received", { payload, row, newVal });
        } catch (e) {}
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          const updated = updateChannelFieldByID(
            channelID,
            "durations",
            newVal
          );
          if (updated) return;
          try {
            debugLite.log("msg.duration.byChannelID", {
              channelID,
              newVal,
              updated,
            });
          } catch (e) {}
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          const ok = updateChannelFieldByIndex(t, oi, "durations", newVal);
          try {
            debugLite.log("msg.duration.byIndex", { type: t, oi, newVal, ok });
          } catch (e) {}
        } else {
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0) {
            const ok = updateChannelFieldByIndex(
              "analog",
              idx,
              "durations",
              newVal
            );
            try {
              debugLite.log("msg.duration.byLabel", {
                type: "analog",
                idx,
                newVal,
                ok,
              });
            } catch (e) {}
          } else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0) {
              const ok = updateChannelFieldByIndex(
                "digital",
                idx,
                "durations",
                newVal
              );
              try {
                debugLite.log("msg.duration.byLabel", {
                  type: "digital",
                  idx,
                  newVal,
                  ok,
                });
              } catch (e) {}
            }
          }
        }
        break;
      }
      case CALLBACK_TYPE.INVERT: {
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newVal =
          payload &amp;&amp; payload.newValue !== undefined
            ? payload.newValue
            : payload &amp;&amp; payload.invert !== undefined
            ? payload.invert
            : null;
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          const updated = updateChannelFieldByID(channelID, "inverts", newVal);
          if (updated) return;
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          updateChannelFieldByIndex(t, oi, "inverts", newVal);
        } else {
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0)
            updateChannelFieldByIndex("analog", idx, "inverts", newVal);
          else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0)
              updateChannelFieldByIndex("digital", idx, "inverts", newVal);
          }
        }
        break;
      }
      case CALLBACK_TYPE.CHANNEL_NAME: {
        try {
          debugLite.log("channel-name", {
            channelID: payload?.channelID,
            newValue: payload?.newValue ?? payload?.newName ?? null,
            rowId: payload?.row?.id ?? payload?.rowId ?? null,
          });
        } catch (e) {}
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newName =
          payload &amp;&amp; payload.newValue
            ? payload.newValue
            : payload &amp;&amp; payload.newName
            ? payload.newName
            : null;
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          const updated = updateChannelFieldByID(channelID, "yLabels", newName);
          if (updated) return;
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          updateChannelFieldByIndex(t, oi, "yLabels", newName);
        } else {
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0)
            updateChannelFieldByIndex("analog", idx, "yLabels", newName);
          else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0)
              updateChannelFieldByIndex("digital", idx, "yLabels", newName);
          }
        }
        break;
      }
      case CALLBACK_TYPE.GROUP: {
        // payload shapes similar to other fields: { row, newValue } or [_, channelID, newValue]
        let row = payload &amp;&amp; payload.row ? payload.row : null;
        let channelID = null;
        const newGroup =
          payload &amp;&amp; payload.newValue !== undefined
            ? payload.newValue
            : payload &amp;&amp; payload.group !== undefined
            ? payload.group
            : null;
        if (!row) {
          if (Array.isArray(payload) &amp;&amp; payload.length >= 3)
            channelID = payload[1];
          else if (payload &amp;&amp; payload.channelID) channelID = payload.channelID;
        }
        if (channelID) {
          // find by id and update groups array
          const found = findChannelByID(channelID);
          if (found) {
            channelState[found.type].groups =
              channelState[found.type].groups || [];
            channelState[found.type].groups[found.idx] = newGroup;
            return;
          }
        }
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);
        if ((t === "analog" || t === "digital") &amp;&amp; oi >= 0) {
          channelState[t].groups = channelState[t].groups || [];
          channelState[t].groups[oi] = newGroup;
        } else {
          // fallback: find by label
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0) {
            channelState.analog.groups = channelState.analog.groups || [];
            channelState.analog.groups[idx] = newGroup;
          } else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0) {
              channelState.digital.groups = channelState.digital.groups || [];
              channelState.digital.groups[idx] = newGroup;
            }
          }
        }
        break;
      }
      case CALLBACK_TYPE.ADD_CHANNEL: {
        const ch = payload;
        if (!ch) return;
        const t = (ch.type || ch.row?.type || "").toLowerCase();
        const isAnalog = t === "analog" || ch.type === "Analog";

        // requested insertion index (in the per-type arrays) may be provided by child
        let requestedIndex = Number(ch.requestedIndexInType);
        if (!Number.isFinite(requestedIndex) || requestedIndex &lt; 0)
          requestedIndex = null;

        // assign a stable channelID for the new channel
        const assignedID =
          (isAnalog ? "analog" : "digital") +
          "-" +
          Math.random().toString(36).slice(2, 9);

        // ensure arrays exist
        const target = isAnalog ? channelState.analog : channelState.digital;
        target.yLabels = target.yLabels || [];
        target.lineColors = target.lineColors || [];
        target.scales = target.scales || [];
        target.starts = target.starts || [];
        target.durations = target.durations || [];
        target.inverts = target.inverts || [];
        target.channelIDs = target.channelIDs || [];

        // compute actual insert index (clamped)
        const insertAt = (() => {
          const len = target.yLabels.length;
          if (requestedIndex == null) return len; // append
          const i = Math.max(0, Math.min(len, Math.floor(requestedIndex)));
          return i;
        })();

        // insert into per-channel arrays at insertAt
        target.yLabels.splice(
          insertAt,
          0,
          ch.id || ch.name || (isAnalog ? "New Analog" : "New Digital")
        );
        target.lineColors.splice(insertAt, 0, ch.color || "#888");
        target.scales.splice(insertAt, 0, ch.scale || 1);
        target.starts.splice(insertAt, 0, ch.start || 0);
        target.durations.splice(insertAt, 0, ch.duration || "");
        target.inverts.splice(insertAt, 0, ch.invert || false);
        target.channelIDs.splice(insertAt, 0, assignedID);

        // Also insert a placeholder series into dataState (and data) so charts keep series aligned
        try {
          const dtype = isAnalog ? "analog" : "digital";
          const arr = dataState &amp;&amp; dataState[dtype];
          const raw = data &amp;&amp; data[dtype];
          if (Array.isArray(arr) &amp;&amp; Array.isArray(arr[0])) {
            const timeArr = arr[0];
            const n = timeArr.length;
            const placeholder = new Array(n).fill(isAnalog ? NaN : 0);
            // series arrays start at index 1 (0 is time)
            const seriesInsertAt = insertAt + 1;
            arr.splice(seriesInsertAt, 0, placeholder);
            if (raw &amp;&amp; Array.isArray(raw))
              raw.splice(seriesInsertAt, 0, placeholder.slice());
          }
        } catch (e) {
          console.warn(
            "Failed to insert placeholder series for new channel",
            e
          );
        }

        const assignedIndex = insertAt;

        // ack back to the child (if possible) so it can update its row metadata
        try {
          ev.source &amp;&amp;
            ev.source.postMessage(
              {
                source: "ParentWindow",
                type: "ack_addChannel",
                payload: {
                  tempClientId: ch.tempClientId,
                  channelID: assignedID,
                  assignedIndex,
                  type: isAnalog ? "Analog" : "Digital",
                },
              },
              "*"
            );
        } catch (e) {
          /* ignore */
        }
        // Force full re-render so charts pick up the new placeholder series and mappings
        try {
          renderComtradeCharts(
            cfg,
            data,
            chartsContainer,
            charts,
            verticalLinesX,
            createState,
            calculateDeltas,
            TIME_UNIT,
            channelState
          );
        } catch (e) {
          console.warn("re-render after addChannel failed", e);
        }
        break;
      }
      case CALLBACK_TYPE.DELETE: {
        // Accept payload shapes: channelID-based or legacy row object
        const channelID =
          Array.isArray(payload) &amp;&amp; payload.length >= 2
            ? payload[1]
            : payload &amp;&amp; payload.channelID
            ? payload.channelID
            : null;
        if (channelID) {
          const deleted = deleteChannelByID(channelID);
          if (deleted) {
            // Force recreation so chart._channelIndices and series alignment are rebuilt
            renderComtradeCharts(
              cfg,
              data,
              chartsContainer,
              charts,
              verticalLinesX,
              createState,
              calculateDeltas,
              TIME_UNIT,
              channelState
            );
            return;
          }
          // fall through to legacy if delete by ID failed
        }

        const row = payload;
        if (!row) return;
        const t = (row.type || "").toLowerCase();
        const oi = Number(row.originalIndex ?? row.idx ?? -1);

        const perChannelArrays = [
          "yLabels",
          "lineColors",
          "yUnits",
          "groups",
          "axesScales",
          "scales",
          "starts",
          "durations",
          "inverts",
          "channelIDs",
        ];

        const removeSeriesForType = (type, index) => {
          const s = channelState[type];
          perChannelArrays.forEach((name) => {
            if (s[name] &amp;&amp; Array.isArray(s[name])) {
              if (index >= 0 &amp;&amp; index &lt; s[name].length)
                s[name].splice(index, 1);
            }
          });
          try {
            const arr = dataState &amp;&amp; dataState[type];
            const raw = data &amp;&amp; data[type];
            const seriesIdx = index + 1;
            if (
              Array.isArray(arr) &amp;&amp;
              seriesIdx >= 1 &amp;&amp;
              seriesIdx &lt; arr.length
            ) {
              arr.splice(seriesIdx, 1);
            }
            if (
              raw &amp;&amp;
              Array.isArray(raw) &amp;&amp;
              seriesIdx >= 1 &amp;&amp;
              seriesIdx &lt; raw.length
            ) {
              raw.splice(seriesIdx, 1);
            }
          } catch (e) {
            /* non-fatal */
          }
        };

        if (t === "analog" &amp;&amp; oi >= 0) {
          removeSeriesForType("analog", oi);
          renderComtradeCharts(
            cfg,
            data,
            chartsContainer,
            charts,
            verticalLinesX,
            createState,
            calculateDeltas,
            TIME_UNIT,
            channelState
          );
          return;
        } else if (t === "digital" &amp;&amp; oi >= 0) {
          removeSeriesForType("digital", oi);
          renderComtradeCharts(
            cfg,
            data,
            chartsContainer,
            charts,
            verticalLinesX,
            createState,
            calculateDeltas,
            TIME_UNIT,
            channelState
          );
          return;
        } else {
          // fallback: delete by label match
          let idx = channelState.analog.yLabels.indexOf(row.id ?? row.name);
          if (idx >= 0) {
            removeSeriesForType("analog", idx);
            renderComtradeCharts(
              cfg,
              data,
              chartsContainer,
              charts,
              verticalLinesX,
              createState,
              calculateDeltas,
              TIME_UNIT,
              channelState
            );
            return;
          } else {
            idx = channelState.digital.yLabels.indexOf(row.id ?? row.name);
            if (idx >= 0) {
              removeSeriesForType("digital", idx);
              renderComtradeCharts(
                cfg,
                data,
                chartsContainer,
                charts,
                verticalLinesX,
                createState,
                calculateDeltas,
                TIME_UNIT,
                channelState
              );
              return;
            }
          }
        }
        break;
      }
      default:
        // unknown message type - ignore
        break;
    }
  } catch (err) {
    console.error("Error handling child message:", err);
  }

  // â±ï¸ DIAGNOSTIC: Log detailed breakdown of where time was spent
  const msgEndTime = performance.now();
  const totalTime = msgEndTime - msgStartTime;

  if (totalTime > 30) {
    console.warn(`[Performance] âš ï¸ SLOW Message processing: ${type}`, {
      totalMs: totalTime.toFixed(2),
      detail:
        "ðŸ¢ Check if: debugLite.log() is slow, subscribers are blocking, chart.redraw() is expensive",
      performance:
        totalTime > 500
          ? "ðŸ”´ VERY SLOW (FREEZE!)"
          : totalTime > 200
          ? "ðŸ”´ SLOW"
          : totalTime > 100
          ? "ðŸŸ¡ MEDIUM"
          : "ðŸŸ¡ OK",
    });
  } else if (totalTime > 10) {
    console.log(`[Performance] âœ… Message processing: ${type}`, {
      totalMs: totalTime.toFixed(2),
      performance: "ðŸŸ¢ FAST",
    });
  }
});
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
